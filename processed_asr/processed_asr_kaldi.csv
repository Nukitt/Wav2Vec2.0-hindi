list it does not mean that the functions that are defined for list are actually legal,list it does not mean that the functions that are defined for lists are actually legal for 
you would have for instance a function like say push define and it will have to parameters,you would have for instance a function like say push define and it will have two parameters 
a l pass to now this call this function in it which is why x called init so any,value l passed to it now this calls this function init which is why it is called init so init 
delete max define for keeps but its call like we have a separate copy of this function,delete max define for heaps but it is like we have the separate copy of this function 
it max normal the how the priority queue is actually implemented then in the delete max show,max no matter how the priority queue is actually implemented internally the delete max should 
the other concrete data types which we use a none,they have a concrete data types which we use in our program  
not want to look at the implementation and ask whether its a list of not because we,not want to look at the implementation and ask whether it is a list or not because we 
this weekâ€™s lectures so let us revisit what we mean by data structure so a data structure,weeks' lectures let us revisit what we lean by a data structure 
the important thing is that we would like,u the important thing is that we would like 
implementation but we definitely to do not want the implementation to determine,to the implementation but we definitely do not want the implementation to determine how 
that we use a sees as a sequence of inserts and delete max the user does is the in a different,that the user sees as a sequence of inserts and delete max the user does not see any difference 
the perception that one is pass in the other but the actual correctness of the implementation,a perception that the one is faster than the other but the actual correctness of the implementation 
a for input which shown as a kind of for a thing in the bottom we are if we have is not for input,for input which is shown as a kind of a thing at the bottom here we have the slot for input 
and we have a way to a seen information about the state of the stack so we can imagine,and we have the way to receive information about the state of the stack so we can imagine 
is we only want those operations which the externally visible interface,operations we only want those operations which the externally visible interface or 
the buttons in this case of a black box picture allow us to use,the buttons in this case of the black box picture allow us to use 
twice the we define dd to be an empty dictionary then we can use a function such as d dot values,likewise if we define d to be an empty dictionary then we can use a function such as d dot values 
is to get the list of values currently stored but we cannot manipulate the as a list,to get the list of values currently stored but we cannot manipulate d as a list so 
we cannot say p dot append it will give us an error so python uses the type information,we cannot say d dot append it will give us an error python uses the type information 
whose behavior specified without telling us anything about the internal implementation,whose behavior is specified without telling us anything about the internal implementation 
and remove the element at the end of the queue using the function remove queue and for,and remove the element at the head of the queue using the function remove q and for 
possibilities us factors we do not have to look at any number bigger than n because it cannot,possibility as factors we don't have to look at any number bigger than m because it cannot 
first step in our algorithm says to compute the factors of fourteen so by or observation,first step in our algorithm says to compute the factors of 14 so by our observation 
in this case two divides fourteen because fourteen divided to seven but no remainder now three does not update for de,14 dived by 2 is 7 with no remainder now 3 does not divide 4 does not divide 5 does 
seven divides to the seven nine the sixty three then again eight does not divides but nine does then again or,7 divides because 7 9's are 63 then again 8 does not divides but 9 does then again 
are large gap of numbers which do not divide and then twenty one does divide because twenty one threes,there are large gap of numbers which do not divide and then 21 does divide because 21 
sixty three and then finally we find that the last factor that we have is sixty three so in,3's are 63 and then finally we find that the last factor that we have is 63 so if 
here is a very simple way we just go through one of the lists say the list of factors,but here is a very simple way we just go through one of the lists say the list of factors 
of fourteen and for each item in the list we check if it is a factor of sixty three,of 14 and for each item in the list we check it is a factor of 63 
so in this way we have systematically called through one two seven and fourteen and concluded or copy,in this way we have systematically gone through 1 2 7 and 14 and concluded that of these 
extracted the largest one and this in fact these are gcd so this is an example of how this algorithm,extracted the largest one and this in fact is our gcd this is an example of how this 
having done this now we want to return the largest value of in the us list of common factors remember,and having done this now we want to return the largest value of the list of common factors 
fm and fn l will constructed from one to m and one to n the largest value will also be the,fm and fn where constructed from 1 to m and 1 to n the largest value will also be the 
largest common factor between these two let so earlier we i three abstract statements,largest of common factor between these two lists so earlier we had three abstract statements 
this is a definition so def for definition of a function gcd m n,this is a definition so def for definition of a function gcd m n 
the empty list now we need to test every value in the range one to n,the empty list now we need to test every value in the range 1 to n 
is the peculiar to python this returns not the range you expect but one less so if,of peculiarity of python this returns not the range you except but one less so if 
the experience for this group of people you can describe this algorithm by different levels,the experience of this group of people you can describe this algorithm at different levels 
zero then be will append i to the list fm added to the right append is,is 0 then we will append i to the list fn we will add it to the right append is the 
we just said that for each i in from one to m add i to a from if i divides n and now we are done,we just said that for each i from 1 to m add i to fm if i divides m and now we have done 
in that range we have check if it is a divisor and then add it,in that range we have checked it is a divisor and then add it 
factors of n for every j in this range if it divides we append it and now at this point,factors of n for every j in for this range if it divides we append it now at this point 
so says take a list and add a value which value we had the value that we are looking,throughout just take a list and add a value which value we add the value that we are 
python has a short that this is if you want to count the right then we count,python has a shortcut which says that you want to count from the right then we count 
the numbers minus one minus one so long so it says return the minus one,the numbers as minus 1 minus 2 and so on so it says return the minus 1'th element 
that there are other syntactic things your so there are for example you have a base initially,that are other syntactic things here so there are for example you have these punctuation 
these are all features that make python programs are little easier to read and write then programs,these are all features that make python programs a little easier to read and write then programs 
first important point is that we need a way to keep track of intermediate values so,first important point is that we need a way to keep track of intermediate values so 
all the factors in cf so these are all ways of keeping track of intermediate values this,all the factors in cf so these are all ways of keeping track of intermediate values the 
example m and n are numbers similarly i j and f at each step are numbers these,for example m n are numbers similarly i j and f at each step are numbers so these 
and bottom because it would be very difficult to write a program if we have to keep produce,are important because it would be very difficult to write a program if we had to keep producing 
of n regardless of how we can x so these names can the node then we denote single values,of m regardless of how big m is these names can denote can be denote single values or 
the new factor of n we do not want to throw ignored factor we want to take the exist,a new factor of n we do not want to through any old factor we want to take the existing 
the name fm to a new name which takes the old and six and i at the end of,the name fn to a new name which takes the old name and sticks an i at the end of it 
and in terms of that type ability we describe the algorithm itself,and in terms of that capability we describe the algorithm itself 
of y multiplied by two and assign it to a so we will see this as we go along,value of i multiply it by two and assign it to i so we will see this as we go along 
assignment can either assign a completely new value or to update the value use,but assignment can either assign a completely new value or you could update the value using 
the other part that we need to note is how we execute steps so as we said at the begin,the other part that we are need to note is how we execute steps so we said at the beginning 
instance we have to check for every possible factor from one to n if it divides m and the,for instance we have to check for every possible factor from 1 to m if it divides m and then 
is zero if the remainder of m divided by zero then i append so the step append i to f n,is 0 if the remainder of m divided by a is 0 then append so the step append i to fm 
we have repeated steps the same thing done again and again and we have conditionals,we have repeated steps where same thing done again and again and they have conditionals 
essentially this is a good way of illustrating program,but essentially this is a good way of illustrating programming  
of computation for instance if we use a spreadsheet to a range information and,realm of computation for instance if we use a spreadsheet to arrange information and 
we perform some task so have an consists of a sequence of steps which we can think of a,perform some task an algorithm consists of a sequence of steps which can we think of 
it try to invoke of like it from once t to another city it will offer to a range the fly,try to book a flight from one city to another city it will offer to arrange the flights 
can get from way to be and b an up all the different ways we can get from a to be we want the optimum,get from a to b and b among all the ways we can get from a to b we want the optimum 
and that is what we call a data structure,and that is what we call a data structure 
its so k is a divisor of m if i can divide m by k and get no reminder so the,divides so k is a divisor of m if i can divide m by k and get no reminder so the 
when we can see that for is a factor of eight for is a divisor of eight for is also a divisor,12 then we can see that 4 is the factor of 8 4 is the divisor of 8 4 is also divisor 
of two where another divisor of to the six but six is not a divisor of eight so we go through the,of 12 another divisor of 12 is 6 but 6 is not a divisor of 8 so if we go through the 
the bigger than one that divides both eighteen and twenty five since one divides,bigger than 1 that divides both 18 and 25 since 1 divides every number as we saw in 
how would one go about computing gcd of m and n so this is where we come to the algorithm it,so how would one go about computing gcd of m n so this is where we come to the algorithmic 
algorithm it but we want to describe uniform way of systematically computing gcd of m and n for any,way we want to describe the uniform way of systematically computing gcd of m n for any 
better once as we go along but if we just look at the definition of gcd it says,better once as we go along but if we just look at the definition of gcd it says look 
at all the factors of n look at all the factor of n and find the largest one which is a,at all the factors of m look at all the factor of n and find the largest one which is the 
what we want from an algorithm a two things one as that the description of what to do,we want from an algorithm are two things one is that the description of what to do 
instructions that r is of the value of m and n in such a way that concrete and comp we,the instruction regardless of the value m and n in such a way it can read it and comprehend 
factors have a very large number for n we might have any factors so the process,factors they are the very large number for n you might have many factors so the process 
we have seen several situations where we want store a sequence of values,we have seen several situations where we want to store a sequence of values 
out in a list it is expensive to get to the ith element it takes time to portion,therefore in a list it is expensive to get to the ith element it takes time proportional 
at the ith position that the value at the jth position in constant time independent of i,at ith position get the value at the jth position in constant time independent of i 
two up to j position to get the two positions so i will have and in a list or would have,down to the jth position to get the two positions so i will have in a list i would have the 
sequence of links and then i will have in our this sequence of things,sequence of links and then i would have another sequence of links 
then having now identify block where the ith value is in the block but j,then having now identified the block where the ith value is and the block where the jth 
the length of each element of the array is of a uniform size x and,length of each element of the array is of a uniform size 
to design for sequences apply depending on how the sequence is actually represented,to design for sequences apply depending on how the sequence is actually represented 
an algorithm which works efficiently for a list may or may not work efficiently for an x,an algorithm which works efficiently for a list may or may not work efficiently for an 
i and vice is us to,array and vice versa 
you would also typically in an array know in advance how the this block,we would also typically in an array no in advance how big this block is 
or we can even call it a sequence more size the sequence which we call s e queue,or we can even call it a sequence to be we more precise in a sequence which we call seq 
so we have a sequence of values we want to check whether a given value there and,so we have a sequence of values we want to check whether a given value is there or not 
for does it matter does not matter how,or does it matter does it not matter at all 
we only need true or false it is if there of this is not it is a very simple thing,only need true or false is it there or is it not it is a very simple thing 
we do is we to through all the elements in the sequence and check whether any element,what we do is we loop through all the elements in the sequence and check whether any element 
that if we have reach this point we have not found the value three that we are looking for,that we have reached this point we have not found the value v that we are looking for 
and check the value at position i rather than the value itself,and check the value at position i rather than the value itself 
may point of this function is that we have no solution to search other than to scan,the main point of this function is that we have no solution to search other than to scan 
this value might be,this value might be 
of memory starting with one two three up to i and you want to get to the ith element quickly by,of memory starting with 1 2 3 up to i right and you want to get to the ith element quickly 
v is the last value then we have to look at all,so v is the last value then we have to look at all 
more generally v is not in the list right,but more generally v is not in the list 
v is not in the list the only where we can determine that the is not in the list is to check every value,v is not in the list the only way we can determine the v is not in the list is to check every 
have not seen it so far we are not going to see play to,have not seen it so far we are not going to see it later 
a sequence starts you can just compute i times this size of one unit and quickly come,the sequence starts you can just compute i times this size of one unit and quickly go 
have to look at any word before,to look at any word before i 
so in general if we have a sequence that efficient way to search for this value is to first,in general if we have a sequence that efficient way to search for this value is to first look 
like that and somebody are still to guess the name of a person there leaking out,play that when somebody ask you to guess the name of a person they are thinking of then 
this is no then you only need to think about n we of n,person says no then you only need to think about m so we have men 
on this how would we do the,on this 
again we look at,how would we do that 
to next part that we look at and so on,of the next part that we look at and so on 
we will demarcate that segment using l and,so we will demarcate that segment using l and r 
is to the ith position,to the ith position 
the other hand the slice is not empty then what we do is we first compute the midpoint so we can,on the other hand if the slice is not empty then what we do is we first compute the midpoint 
so we find the midpoint,so we find the midpoint 
and this can be done in what we call constant time in that,and this can be done in what we could call constant time 
and therefore it stops at bit minus,and therefore it stops at mid minus 1 
give us the slice which is empty because we find that the right point,give us a slice which is empty because we will find at the right point at the left point 
the left pointer the same,are the same 
so or the sequence length zero then the takes only one step because we just report that,if the sequence has length 0 then it takes only one step because we just report that 
it is false we can find it if there are no elements left otherwise,it is false we cannot find it if there are no elements left 
we want to an expression for t of n which satisfies this so this is what is called a recurrence normally sil,we want an expression for t of n which satisfies so this is what is called a recurrence normally 
one by t of n by two cube,plus 1 by t of n by 2 cube 
y and then this expression becomes one so when n is equal to two to the k it,so when this expression becomes 1 so when n is equal to 2 to the k 
the log of thousand to the base two that is the equivalent definition of all,the log of 1000 to the base 2 and that is an equivalent definition of log 
that the midpoint,at the midpoint 
we search is that by only looking at a very small number of values space of example we can,search is that by only looking at a very small number of values say for example we give 
of so after it ten halvings of thousand we would a come down to zero or one,after 10 halvings of 1000 we would have come down to 0 or 1 
us that i get when i use an array,bonus that i get when i use an array 
or r the arrays,or are they arrays 
so they do support these flexible things which are typical of lists however python supports,they do support these flexible things which are typical of lists however python supports 
two and just to emphasise how lists work when we go further in this course we will actually,to and just to emphasise how lists work when we go further in this course we will actually 
we look at how to implement some data structures,look at how to implement some data structures 
in one element to the,one element to another 
fit with key it is not very efficient to expanded because we have two then shift everything,of it quickly it is not very efficient to expand it because we have to then shift everything 
the worst case for example if this green blah comes in the zero a position then the entire,the worst case for example if this green block comes into 0th position then the entire 
you can imagine that you know if you have some say a space in your covered and then you take a,you can imagine that if you have some say space in your cupboard and then you take out 
we can also accommodate what we see in python where each element of the list make,another we can also accommodate what we see in python where each element of the list maybe 
of a different type and hence each value might have a different size in itself,of a different type and hence each value might have a different size in itself 
s time proportional to i we cannot assume that we can reach any position in the list in constant,time proportional to i we cannot assume that we can reach any position in the list in constant 
it is,like this 
we say that the ith position points to the i plus one position which point to the rest the,we say that the ith position points to the i plus 1th position which point to the rest 
many problems we have to search through a set of possible these in order to find this solution,for many problems we have to search through a set of possibilities in order to find the 
x search through all the possibilities by going forwards in backwards one that the attack,search through all the possibilities by going forwards and backwards one level at a time 
our first question is how to represent the board because the board is what keeps changing,problem so our first question is how to represent the board because a board is what keeps changing 
i comma j and therefore if it is zero in the case,comma j and therefore if it is 0 it indicates there 
know that there is only one queen for row so this particular thing though it has n minus ten it,that there is only one queen per row this particular thing though it has n minus n into 
when n square entries it will only have actually n once at any given time so we can optimal,n n square entries it will only have actually n ones at any given time so we can optimize 
now if you have update chess you would know that the queen is a very special these,now if you have ever played chess you would know that the queen is a very special piece 
report just means setting board i equal to see if we have the one dimensional representation,our board just means setting board i equal to c if we have the one dimensional representation 
from zero then we are done so we can return true however this is not the last queen then,0 then we are done so we can return true however if this is not the last queen then 
is one more queen so we recursively call this function incrementally the row to i plus one,one more queen so we recursively call this function incrementing the row to i plus one 
it can move any number of squares is a longer row column or diagonal so for instance,it can move any number of squares along a row column or diagonal  for instance if 
have other the succeeds or not we check if extend solution is true that is,depending on whether it succeeds or not we check if extend solution is true that is the 
current position reaches c and r where bounded we true if it to succeeded,current position reaches the end now when would it be true if it succeeded 
in going all the data level n minus one and n minus two returns true so when n minus one to,in going all the way to level n minus 1 and n minus 1 returns true so when n minus 1 
if we place a queen here in the third on the third column then at it move anywhere,we place the queen here in the third row and the third column then it could move anywhere 
you have to do a little bit more work to figure out how to actually printing this,but we have to do a little bit more work to figure out how to actually implement this 
a simple way would be to just sake that along with a two dimensional representation the,a simple way would be to just say that along with a two dimensional representation of the 
that say attack i j is k if i the was first attacked by queen k and attack i j is minor,so we say attack i j is k if i j was first attacked by queen k and attack i j is minus 
queen i that we put you we mark the squares which are attacked by queen i,we put we only mark the squares which are attacked by queen i 
back so removing date it does not actually change anything regarding the attack this,attack so removing it does not actually change anything regarding the attack position 
placed under attack only are adding this queen and that turns out to be,were placed under attack only after adding this queen and that turns out to be these 
first attacked by queen k and when we remove queen k we reset to minus one saying that,first attacked by queen k and when we remove queen k we reset to minus one saying that 
array which had code i equal to b j so question is can we replace a attacked by,array which had board i equal to be j the question is can we replace attack by a 
in the array now one thing to remember is that though attack itself is an n squared,linear array now one thing to remember is that though attack itself is an n squared 
once we fix the queen two and two we only have to look along its row call a,entries once we fix the queen to undo we only have to look along it is row column 
this main diagonal so for the main diagonal is the one from the top left,this main diagonal or the off diagonal the main diagonal is the one from top left 
since in which square to be under attack so we where we better to represent these code directions,in which a square could be under attack it might be better to represent these 4 directions 
minus the row is something that will be the same a long every square of that i,minus the row is something that will be the same along every square on that diagonal 
and along this green diagonal we have seven plus five six the string some five plus seven so sequence r is equal to two or not,and along this green diagonal we have 7 plus 5 6 plus 6 and 5 plus 7 so c plus r is 
this j minus i or is along the diagonal this difference is j plus as to some is j,is j minus i or if is along the diagonal whose difference is j plus i whose sum is j plus 
similarly we can have a an array which says column nice f add and then call,n minus 1 similarly we can have a an array which says column i is attacked and then column 
my set to one provided column i is attacked for again i a between zero and n minus one now in,i is set to 1 provided column i is attacked for again i between 0 and n minus 1 now when 
the north west to south east diagonal is the one where the difference is the same,the north west to south east diagonal is the one where the difference is the same and if 
and here the difference is seven minus zero is seven and here the difference is zero minus seven is fine,here the difference is 7 minus 0 is 7 and here the difference is 0 minus 7 is minus 
one to n minus one this is we can number if at so this is the difference is the difference this,n minus 1 this gives me the number if at this is the difference if the difference is 
and the possible range of values it is from minus seven plus m minus n minus one,are there and the possible range of values is from minus 7 to plus 7 minus n minus 1 
put and then minus one is two times seven which is four,two times n minus 1 is two times 7 which is 14 
the values are zero to n minus one so minus one indicates that the ith queen is not placed that this moment,the values are 0 to n minus 1 so minus 1 indicates that the ith queen is not placed 
attacked by a single queen and must be attacked by the queen at i comma j so only the queen,by a single queen and it must be attacked by the queen at i comma j so only the queen 
key values indicating the five some dictionaries so the queen position we will call keep,5 key values indicating the 5 sub dictionaries the queen position we will call the key queen 
queen so instead of saying board i is j we say board with queen as the key add position,so instead of saying board i is j we will say board with queen as the key at position 
which is a dictionary which contains everything of reverse,which is a dictionary which contains everything of interest 
diff so here we have an actual python implementation of what we discussed so we have this a is,here we have an actual python implementation of what we discussed so we have this this 
function here which is called place queen to place a queen we set takes the row i and the,function here which is called place queen place queen we said takes the row i and the 
or column values we check if i js tree in the current board if it is free then we,all column values we check if i j is free in the current board if it is free then we 
we means to queens we cannot place a queen and the as rows we return false now,we means it means we cannot place the queen on the ith row so we return false now the 
so remember we take the input it will be a string we convert it using int and we are caught,so remember we take the input it will be a string we convert it using int and we record 
mid and pass it as n then we will initialize the board at the number n we need n because,int and passes it as n then we will initialize the board with the number n we need n because 
need to know how to set up that remember that the indices and from zero to n minus one or from n,we need to know how to set up that remember that the indices run from 0 to n minus 1 or 
n minus n minus one plus and so n this required in order to initialize the dictionary,n minus n minus 1 plus n n is required in order to initialize the dictionary and finally 
initializes the board what how do we print the board for any row we sort,this initializes the board what how do we print a board well for every row we sort the 
files so this is a if you have a python program we can run it directly without first,dot py this is by the way if you have a python program you can run it directly without first 
instance if we give it the number for then we that this solution that we saw in the,for instance if we give it the number 4 then we will get the solution that we saw in the 
example k is not very to print it out the neatly so if we get the,earlier example it is not very printed out very neatly so if we give the number 8 then 
shows we the for queen solution one more readable found,shows me the 4 queen solution in a more readable form right 
means m is bigger is an extra call it is an saying that but is next all,see there is an extra column there is some mistake in that but there is an extra column 
previous level also returns true and eventually we print out the board so supposing we do not,previous level also returns true and eventually it print out the board supposing we do not 
so every possible solution the only thing is that it will not run through a,every possible solution the only thing is that it will not run through every solution 
queen positions and then try and it out we are trying it out for smaller a things because,queen positions and then trying it out we are trying it out for smaller things because 
us a we extend solution and then we undo the queen and try the next one,extend the solution and then we undo the queen and try the next one 
every possible j an inorder there the amount containing,blindly try every possible j and we are not going to ever come out complaining that we 
solution that we are trying to get does not work so we take at i get and then we undo,solution that we are trying to get does not work so we hit a dead end and then we undo 
part a special a backtracking with respect to the eight queens got,our discussion of backtracking with respect to the 8 queens' problem  
and there is no free slot for the third queen so just i exhausted on as is we can show,there is no free slot for the third queen so just by exhaustive analysis we can show 
we can find an empty slot of the second node right at the end so we put a queen there,then we can find an empty slot on the second row right at the end so we put a queen there 
everything is one of the column in is none the queens attack each other,everything is one of the corner in which none of the queens attack each other 
is always a solution possible now up our last is to find such a solution how to we find,is always a solution possible our task is to find such a solution how do we find a 
that there exactly one queen in each row so let us first put a queen in the first row,is exactly one queen in each row let us first put a queen in the first row 
so we have a print and then you start filling up things and then i some caught,so you have a grid and then you start filling up things and there are some points you realize 
its now we move to the third row and that is call,squares now we move to the third row and in the 5th 
speed and then we place a queen and then or six one and then or seven one and now we find,and then we will place a 5th queen and then a 6th one and then a 7th one and now we find 
something we did for now the last thing we did was to put the seven is queen right so we,something we did before now the last thing we did was to put the 7th queen right so 
the problem and at some point when we realize that we are start we cannot solve the problem,problem and at some point when we realize that we are stuck we cannot solve the problem 
and so on,and so on 
suppose we want to write a function find pops which finds the first position of the value,suppose we want to write a function findpos which finds the first position of a value 
go this let reached how to we know at this point so remember now there are,not think of this clever trick how would we know at this point so remember now there 
so the question is can we detect whether or not to broke out of this loop order the,not the question is can we detect whether or not we broke out this loop or whether we 
we terminated separately,terminate it separately 
in that looks a bit odd because of the name it allows something called else which,that looks a bit odd because of the name it allows something called else which we saw 
the new words you need to use so if you see an else attach to a for it could also be a,new words you need to use if you see an else attached to a 'for' it could also be attach 
is a not found it pos is undefined so it was undefined we need to define it before,entire list and not found it pos is undefined if pos is undefined we need to define it before 
this can be done by up supplying the optional x so both for and while also the of l,this can be done by supplying the optional else both for and while also allow an else 
we mark the position that we have found it to be pops at the end of this if we have not found,mark the position that we have found it to be pos at the end of this if we have not 
we in the list then we will set pos to minus one which is the default value we indicate,in the list then we will set pos to minus 1 which is the default value we indicate at 
to scan the remaining hundreds of thousands of positions before we return the position,to scan the remaining hundreds of thousands of positions before we return the position 
so this is an issue of deficiencies that we are done in this to many times and,this is an issue of efficiency that we are running this loop too many times unnecessarily 
the position to be the new thing right so we are actually finding not the first,the position to be the new thing so we are actually finding not the first 
position to the last position so this is not a very good way to do this and so we first,position but the last position so this is not a very good way to do this so we first 
condition it says that if l i is b and we have not found it so far then we update,condition which says that if l i is v and we have not founded so far then we update 
the as before if we never find it then the value found is never set to true and so we report,as before if we never find it then the value found is never set to true and so we report 
succeeding then we will report minus one,without succeeding then we will report minus 1 
so we could think covering this using a for loop n so we go through every value and,we could think of doing this using a 'for loop' so we go through every value in l 
we have not seen x so far like before we want to report minus one,have not seen x so far like before we want to report minus 1 
the position so this is only the first version of this we will see how to fix this so we have,position this is only the first version of this we will see how to fix this so we have 
in one so this is precisely what we want to do if x is be we have found the first position,loop so this is precisely what we wanted to do if x is v we have found the first position 
we go back and now how do we record at the end we do not have this founded filling,and go back now how do we record at the end we do not have this found variable anymore 
im on how do we know in the n to whether or not we actually sort so the question is was call,how do we know at the end whether or not we actually saw it so the question is was pos 
there so in any case we can return pos in we have node,there so in any case we can return pos and we have no problem 
this is just to illustrate the use of the word break it which allows us in certain situations,this is just to illustrate the use of the word break which allows us in certain situations 
to get a remember in the worst case we do not find x so the worst case,to get out now remember in the worst case we do not find x in it so the worst case 
it is better to scan the positions so is better to say pos is minus one but,it is better to scan the positions so it is better to say pos is minus 1 but instead 
to going through x in l means better to go through i in the range zero remember now this,of going through x in l it is better to go through i in the range 0 remember now this 
did so while the changing the they will that we put in the for we were slightly more matches,so by changing the variable that we put in the 'for' we have got a slightly more natural 
the last lecture we saw that in object oriented programming we define a data type,in the lecture we saw that in object oriented programming we define a data type through 
are dealing with this heap h when we say h dot insert then this insert is using the value,are dealing with this heap h when we say h dot insert then this insert is using the 
us better the same function is that there is self there is what is turns,perspective the same function is there there is self there is o distance so if i take 
eight and y equal to r sign theta then into x plus delta x y plus delta y and convert,theta and y equal to r sin theta then do x plus delta x y to plus delta y and convert 
it back to r theta so you pay or tries in one function of the other that x,it back to r theta right so you pay a price in one function or the other with the x y 
like saying that a heap implementation is always better than a sorted list implementation,like saying that a heap implementation is always better than a sorted list implementation 
quite implementation namely we have to move from x y to r theta but the functionality,the private implementation namely we have moved from x y to r theta but the functionality 
are which three comma four but if we do not pass the argument set p two then we get a point,the argument 3 comma 4 but if we do not pass any argument like p 2 then we get a point 
and the origin,at the origin 
a function in end clearly looks like a special function because of these underscore,the function init clearly looks like a special function because of these underscore underscore 
using right python function as we said before python a interprets in it is the constructor so,to write a python function as we said before python interprets init as a constructor so 
when we call a object like equal to point five for then this implicitly call so init and when it is use whose,when we call a object like p equal to 054 then this implicitly calls init and init is 
for instance print it to the function print implicitly takes any name you passed to print,and for instance print  the function print implicitly takes any name you pass to print 
self dot y we want to print this out in this found the value x in the value i,and self dot y we want to print this out in this form value x and the value y 
put it so the string representation of self dot y so this creates a string now the value,produces the string representation of self dot y this creates a string from the value 
the other heaps it we will see it later that we can take one value refer to another value,other heaps we will see a little later that we can take one value and refer to another 
to define what i mean so let us assume that we want to construct a new point whose x coordinate,define what add means let us assume that we want to construct a new point whose x coordinate 
here is a way we would do it we would create a new point whose it x coordinate is self dot x,here is way we would do it we would create a new point whose x coordinate is self dot 
is implicitly called self because that is the one that is to be the manipulated to by function so the main the left,implicitly called self because that is the one that is typically manipulated by a function 
we just i p one less than p two for a deleting have in our program and internally to,we just write p 1 less then p 2 for readability enough in our program and internally it will 
point is given some code it like a common so this is a point use export it is a while count,point is given some coordinate like a comma b this is a point with xcoordinate a and 
in this is the familiar concept that all a few steps even mathematics,ycoordinate b this is a familiar concept that all of you must have seen in mathematics 
a and b that you want to point you have and now we have within the for a point we have,and b that you want point to have and now we have within the point we have 
as objects,as objects 
and y value and this x value is something and the y value and n if we change the,a y value and this x value is something and the y value is something and if we change 
this particular object now this particular object changes as we move to one out,this particular object now this particular object changes as we move from one object 
to be to self is b and this is an important thing so just remember that every function inside,of p 2 self is p 2 this is an important thing just remember that every function inside 
three will be passed as a an two will be passed says v and this will set up a point that we have brown to,will be passed as a and 2 will be passed as b and this will set up a point that we 
the value that i x so you want self dot x plus delta x now this is a very common,the value delta x so you want self dot x plus delta x now this is a very common paradigm 
to delta x is just a short cut in python for self dot x equal to self dot x plus n times,to delta x is just a short cut in python for self dot x equal to self dot x plus delta 
is it means that implicitly the name on the left is the first argument to the operation,x it means that implicitly the name on the left is the first argument to the operation 
so for instance now if we say p dot translate to one then we get a new point which is the plus two file,for instance now if we say p dot translate 2 1 then we get a new point which 3 plus 2 
so let us look at a different functions so supposing we want to compute the distance from of o,let us look at different functions so supposing we want to compute the distance of a point 
is to this to get insist in this way we will assign this to a name a let us call it,distance to get its distance maybe we would assign this to a name let us not call it 
us call itself so let us just assuming that this parameter is to,to always call it self let us just assume that this parameter is 
now if o distance is something that we need to often them a range useful to just,now if o distance is something that we need to do often then may be it's useful to just 
this distance and you can keep this and so if i have r and theta is the same information,keep this distance and you can keep this angle so if i have r and theta it's the same information 
r cos theta that cos is a can omitted cosine function y is equal passing theta it and,r cos theta where cos is the trigonometric cosine function y is equal to r sin theta 
different types of expressions which have different values like the types we have c,different types of expressions which have different values like the types we have seen 
similarly any empty sequence such as the empty string the empty list is also data,similarly any empty sequence such as the empty string or the empty list is also treated 
so remember if it is not equal to zero then it is to right so when it is not equal to zero does true so,remember if it is not equal to 0 then it is true 
if this condition holds the same as asking whether m percent n is a nonzero value and,if this condition holds is the same as asking whether m percent n is a nonzero value and 
if it is nonzero value we want to replace m and n so we can just write if m percent,if it is nonzero value we want to replace m and n so we can just write if m percent 
on whether it is one two three or four you want to do four different things which we will which will be caught,on whether it is 1 2 3 or 4 you want to do four different things with which we called 
left one it to where three and four,f1 f2 f3 and f4 
us check if x is equal to one then we invoke f one,supposing we first check if x is equal to 1 then we invoke f1 
x is not one then it is one of the others so all of this goes into an else in everything,if x is not 1 then it is one of the others so all of this goes into an else and everything 
we check in this case of x is equal to two then we do a to otherwise we have three of four,then we check in this case if x is equal to 2 then we do f2 otherwise we have 3 or 
up one then we check two or not to which a three or not three then we have is ugly nesting and secondly we have the,2 and then we check 3 or not 3 then we have this ugly nesting and secondly we have this 
us shortcut for list which is to combine the else and the if into a second,python has a shortcut for this which is to combine the else and the if into a second 
a l the,check elif 
so this is on the right is exactly the same as the left as far as five in this concerned,so this on the right is exactly the same as the left as for as python is concerned 
otherwise it will invoke the rest of the rest,otherwise it will invoke the rest 
to what does happen so far according to the current values that we see,what has happened so far according to the current values that we see 
to the outcome of this in,so this should be outcome of this loop 
let us look at earlier like example,let us look at a real life example 
so the range zero one we said starts at zero and rid generates a sequence of the form zero one two,the range 0 1 we said it starts at 0 and it generates the sequence of the form 0 1 
so range also does and go from zero to n but zero to n minus one so,range also does not go from 0 to n but 0 to n minus 1 
so in general range i j like a slice i to j starts at i and goes up to j minus one,in general range i j like a slice i to j starts at i and goes up to j minus 1 
us look at a simple example of this,let us look at a simple example of this 
suppose we want to find all the factors of a number and all numbers that you write empty without,suppose we want to find all the factors of a number n all numbers that divide n without 
is to be n plus one because the range function stops to one below the number which is the right hand,to be n plus 1 because the range function stops one below the number which is the right 
in a while we come back we check the condition again but there is every possibility that,in a while we come back we check the condition again but there is a every possibility that 
umbrella ever then you visit list the chars of the right,the umbrella ever then you risk the chance of being wet 
so we have to ensure when we write of a while loop that somehow this sequence of statements takes,we have to ensure when we write a while loop that somehow this sequence of statements to 
so long as this is not the case we exchange values for m and n,so so long as this is not the case we exchange values for m and n 
might be useful to just say explicitly not equal to zero just to illustrate yourself,it might be useful to just say explicitly not equal to 0 just to illustrate to yourself 
so we can alter the control flow in three ways we have seen one,we can alter the control flow in three ways we have seen 
you put a condition and then the body is executed each ten the condition is checked again,we put a condition and then the body is executed each time the condition is checked again so 
if it is not likely to rain ensure the umbrella is not in the back if it is not there is,if it is not likely to rain ensure the umbrella is not in the bag if it is not there it is 
is referred to in programming languages us control flow,referred to in programming languages as control flow 
so there are three fundamental things all of which we have seen informally in the g c d case,there are three fundamental things all of which we have see informally in the gcd case 
we want to carry ten boxes from this to two that to so for n times to carry one box a,we want to carry 10 boxes from this room to that room so 10 times we carry one box at 
whether we have to stir it twice of five times we will stir until the sugar dissolves,whether we have to stir it twice or five times we will stir until the sugar dissolves 
l execution in python is written as we saw using the if statement,conditional execution in python is written as we saw using the 'if statement' 
followed by bunch of statements in general,followed by a bunch of statements 
and we have the score and which indicates the end of the condition an,example and we have this colon which indicates the end of the condition 
we make this simultaneous assignment of m taking the old value of n and m taking,we make this simultaneous assignment of m taking the old value of n and n taking the 
so the indentation tells python that these two statements are conditionally executed depend,the indentation tells python that these two statements are conditionally executed depending 
something like a brace to indicate the beginning and the end of the block which is covered,something like a brace to indicate the beginning and the end of the block which is governed 
braces to is braces and so on,and close braces and so on 
we will look at function definitions in more detail very so on and,we will look at function definitions in more detail very soon 
so one tab is not going to be equal to three spaces of for spaces are whatever you see an,so one tab is not going to be equal to three spaces or four spaces or whatever you see 
the sum uniform strategy for example to spaces to indent whenever you have such or nested,some uniform strategy for example two spaces to indent whenever you have such a nested 
if it is likely to rain ensure the umbrella in the back else ensure the umbrella,if it is likely to rain ensure the umbrella is in the bag else ensure the umbrella is 
n is the remainder is zero then we have found the gcd namely the smaller values so the,n if the remainder is 0 then we have found the gcd namely the smaller with two values 
for a final lecture of this first beat we will see in how to actually use python on,for our final lecture of this first week we will see how to actually use python on 
and using if i invoke it will but you some messages then me what type of function,i am using if i invoke it it will produce some messages telling me what type of function 
and now i can also define functions remember how we defined a function we use,with it now you can also define functions remember how we defined a function we use 
is because this computer gets you can finish the error messages from i let us you,spaces because this gets you confuse the error messages form python so let us use 
is to spaces let us is for the sake of up illustration,two spaces let us to the sake of illustration create 
is to complicated to type an without in and say and secondly you might want,is too complicated to typing without make in a mistake and secondly you might want 
get so for this what we need to do is first type of function into a five and then,again for this what we need to do is first type the function in to a file and then load 
come one from so if i have actually we already created something so let us start,the command prompt so i have actually already created something let us start with so i 
with so i use init of or the match you can use any text editor if you are using windows we then you,use an editor called emacs you can use any takes editor if you are using windows you 
the point to remember is that i have make sure that all these indentations,before the point to remember is that i have made sure that all these indentations are 
have this saying number of spaces in it so this is something to remember now you type answer,at the same number of spaces in so this is something to remember now you typing 
as so long as the reminder is not zero we keep updating m and n to n and the reminder define with,says that so long as the reminder is not 0 we keep updating m and n to n and the reminder 
large value that we saw for each i can works say seven nine things n and now use,large value that we saw before and which i think was say 9999999 and 1000000 and now 
it more consistent and more easy reuse but as often happens is a lot of people,makes it more consistent and more easy to use but as often happens a lot of people 
return is somehow or not executable and explains y so do play around with it and,have written is somehow not executable and explains why so do play around with it and 
you may find as we go along with the something that we do not understand a something,may find as we go along that there is something that you do not understand or something new 
one so of not one language even though the features and the syntax the from line,once you have learned one language even though the features and the syntax vary from language 
so this has forced python to point seven to live on eventually we go left somebody will take,so this has forced python 27 to live on eventually we hope that somebody will take 
f or to move python to point seven like reach to python three and of course me for code is larger,the effort to move python 27 libraries to python 3 and of course newer code is largely 
thing we never python three but you should remember that and somebody says that,being developed on python 3 but you should remember that when somebody says that they 
using python we could be talking about to quite seven and not three and you have to make i just ints,are using python they could be talking about 27 and not 3 and you have to make adjustments 
you working a minute is or emac on windows will be able to find a version of python,are working on linux or on a mac or on windows you will be able to find a version of python 
we will see which are slightly different into point seven and we will explore them and three and i will,we will see which are slightly different in 27 and we will explore them in 3 and i will 
is python three fifty three fifty referring to three point five point zero,get to this url so wwwpythonorg downloads release python 350 350 is really refer into 
so actually the current version of this it is not the point by point zero but three point five point to so you will,350 so actually the current version as i said is not 350 but 352 so you will 
and sort these are designed to be fairly self exponent grey install files if you have,and install it these are designed to be fairly selfexplanatory install files if you have 
to the actual programming part,with the actual programming part 
is the distinction between interpreters and compilers so the main difficulties,is the distinction between interpreters and compilers so the main difficultly is that 
and right instructions so these are some what high level instructions the other hand compute,and write instructions on so these are somewhat high level instructions in the other hand 
a ranging chairs so we set our end the chairs as the high level thing and we set would eighty chars,chairs so we said arrange the chairs as a high level thing and we said put 80 chars 
in ten in a two rows n each right so we said that there could be well difference in,in 10 in 8 rows 10 each right we said that they could be a difference in 
we are going to explore in this course and which all programmers normally work,are going to explore on this course and which all programmers normally work with are at 
either the programming language and translates programs and that language to a machine level,level programming language and translates programs on that language to a machine level 
in your language in this case python and the interpreter internally figures out,in your language in this case python and the interpreter internally figures out how 
so we use python typically the following way we first run the interpreters so remember,we use python typically in the following way we first run the interpreters so remember 
you can treated commands and see what is so it is very interactive,calculator you can feed it commands and see what it does so it is very interactive of 
whether using three point five of the point for but there are difference is will be to point seven and three and for,whether you are using 35 or 34 but there are difference between 27 and 3 and for 
right so this will in this with the interpreter,that is written there so this will tell the interpreter to take everything that is 
the so these things will become a little clearer and in that an order n plus one show you,used so these things will become a little clear and then in the demo that i am just 
get into the real details about exactly what goes into a python program,get into the real details about exactly what goes into a python program 
here is any terminal which on windows to be like a command,here is a window showing the terminal which on windows would be like a command prompt 
is ten thousand is how,is 1024 
so when we have ten to the seven the log is going to be something like twenty some things,so when we have 10 to the 7 then the log is going to be something like 20 something 
six some,6
onto one did of three and in many get it exponential is like two to the n and n factorial then unless you have,when you get to the exponentials like 2 to the n and n factorial then unless you have 
an input that is really small like ten or something like that we are going to get problems,an input that is really small like 10 or something like that we are going to hit problems because 
this is an idea that given that how or system that we are working which,this gives us an idea that given that our system that we are working which python can 
what kind of inputs will be realistic to process given the type of algorithm that we are exits,what kind of inputs will be realistic to process given the time type of algorithm that we are 
so this table is more or less valid up to us scaling of a few tens is again in different languages,so this table is more or less valid up to a scaling of a few tens in different languages 
say that the worst case would occur typically when the value that we are trying to find,that the worst case would occur typically when the value that we are trying to find 
if you look that algorithms book score complexity theoretic puts any polynomial in,theoretically if you look at algorithms books or complexity theoretic books any polynomial 
as a very similar limited we can only to about four to five thousand,has a very severe limit we can only do about 4 to 5000 
fix so if you are doing something an n squared time we cannot process something larger than,if you are doing something in n squared time we cannot process something larger than a 
of algorithms,of algorithms 
now unfortunately in order to determine something like an average case in a mathematically this i,now unfortunately in order to determine something like an average case in a mathematically precise 
is we is not very easy we have to have a probability distribution overall inputs and then fresh,way is not easy we have to have a probability distribution over all inputs and then measure 
in between input size and output size so we express this up to proportionality,between input size and output size so we express this up to proportionality 
we are not get a interested in exact constants we want to know for instance is t of n code,so we are not really interested in exact constants we want to know for instance is t of n proportional 
so then are going to going to much detail in this course about how to go is defined,so we are not going to go into much detail in this course about how big o is defined 
and calculate but it is use to useful short hand to describe the been a efficiency of algorithms,and calculate it but it is a useful short hand to describe the efficiency of algorithms 
talk about efficiency as the function of the input sets so,to talk about the efficiency as a function of the input size 
to be it reasonable inputs that we can expect to compute within a few seconds,could be reasonable inputs that we can expect to compute within a few seconds 
we realize that something in the wrong,we realize that something may be wrong 
it to be in f wish,it to be inefficient 
it so if we look at this we have to now figure out how faster computers start,so if we look at this we have to now figure out how fast our computers are 
are we have a bunch of programs which we will take written and here is a play,here we have a bunch of programs if you already written and here is a template 
if i say in gets keep for dot five file,so if i say look at speed4 dot py 
known an input of size n,on an input of size n 
four so for n in range zero to int of ten thousand minus one we just assigns n to be the value and finally the,so for m in range 0 to 10000 minus 1 it just assigns m to be the value i and finally 
is the statement we have been seen so far but which should be quite intuitive which,there is this statement we have not seen so far but it should be quite intuitive which 
is or a bunch of scripts we have written for python from speed4 for to speed9 nine,these are a bunch of scripts we have written for python from speed4 to speed9 
first of all i can take python then i can directly use a name of the python program,first of all i can take python and i can take directly use a name of the python program 
so i can say python three point five and give the name of this and it will execute,so i can say python 35 and give the name of this script and it will execute it and 
if i do this now that by hand five times c then it goes from point zero three,if i do this on the other hand 5 times then it goes from 003 to 05 
it five so is roughly a factor of n as you would imagine it says reason,so it is roughly a factor of 10 as you would imagine which is reasonable 
gone up of a point to second so the,gone up to about 02 seconds 
to the seven takes about the second or more,10 to the 7 takes about the second or more 
a long time in a sitting and can to the screen waiting for that sorts,long time when you are sitting in front of a screen waiting for the response 
so it turns out that this something takes log n of time then even for ten to the ten it takes only thirteen threes,it turns out as something takes log n of time then even for 10 to the 10 it takes only 33 
steps and we have find,steps and we are fine 
of course it line the input is linear then we read or in the constant that the input of size,of course if input is linear then we are ignoring the constant then the input of size 
decreasing what happens when it actually reaches one,decreasing what happens when it actually reaches 1 well 
the remainder will be one will be zero right so we will return gcd of zero in other words we have guaranteed,the remainder will be 0 so we will return gcd of 0 in other words we had guaranteed 
started so this is easy this is euclids are in the first version,start this is euclidã£â€¢s algorithm the first version 
where we observe that the gcd of m and n can be replaced by the gcd of n and m minus n an,where we observe that the gcd of m and n can be replaced by the gcd n and m minus n and 
i will inside compute gcd some other value and use that answer to return answer,well instead compute gcd's on some other value and use that answer to return my answer 
we can n so we instead of starting from one and working upwards to the minimum of m,the beginning so instead of starting from 1 and working upwards to the minimum of m 
and then sees i had so is as though this statement was not part of the python,and then sees the hash so itã£â€¢s as though this statement was not part of the python 
and n it is better to start with minimum of m and n and work backwards to one and,and n its better to start with minimum of m and n and work backwards to one and as 
and put it on a separate line or it input it at the end of the line,can put it on separate line or you can put it at end of the line 
so at this point if we have found n and says that n divides m we are done,do some computation at this point if we have found n such that n divides m we are done 
a time actually produces a remainder so this not equal to simple is written with is exclamation,by n actually produces a remainder so this not equal to symbol is return with this exclamation 
remember that this is double equal to was what we use for the mathematical simpler equality so,remember that this double equal to was what we use for the mathematical symbol of equality 
soon as we find a common factor we report it and exit remember,soon as we find a common factor we report it and exit 
always that one is guaranteed to be a common factor so when we start from minimum,remember always that 1 is guaranteed to be a common factor so when we start from minimum 
worst case n will become one and one will divide everything,worst case n will become 1 and 1 will divide everything 
go to earlier so if it helps we can look at the sign by send try to understand what,wrote earlier so if it helps you can look at these side by side and try to understand 
recursive things is doing and what for while is when an see that we are basically,what this recursive things is doing and what the while is doing and see that they are basically 
into in the same thing and the idea that the recursion must terminate,doing the same thing and the idea that the recursion must terminate 
while exits so just like the recursion can do on forever if you do not,the while exits so just like the recursion can go on forever if you are not careful 
of m and n and go backwards if we do not see any other common factor we are still,of m and n and go backwards if we donã£â€¢t see any other common factor we are still 
are not careful and you do not invoke it with arguments which guarantee termination the while can also,and you do not invoke it with arguments which guarantee termination the while can also 
we can actually do it will better than this so let us see one problem with this by giving an,we can actually do a little better than this let us see one problem with this by doing 
execution so supposing we start with some number like gcd of one hundred and one and two then are of,a hand execution so supposing we start with some number like gcd of 101 and 2 then our 
algorithm will say that this will now become gcd of the difference and n the difference is nineteen,algorithm will say that this should now become gcd of the difference and n the difference 
we keep doing this about fifty steps and then eventually we will come down to we see your five and two,we will keep doing this about 50 steps then eventually we will come down to gcd of 5 and 
the guaranteed that we will exit correctly when we get one so what we notice that was that,guaranteed that we will exit correctly when we hit one so what we notice that was that 
m and for the minimum is to right if we will just computing factors will say there is only factor of two,the minimum is 2 if you were just computing factors we will see that the only factor of 
is two and is not a factor of hundred and one we will stop writing so this actually,2 is 2 and it is not a factor 101 we would have stopped right at beginning this actually 
is use will really worst another we have inserted cases and so on,seems to be worst then our earlier algorithm in certain cases 
though these different versions are simpler than the earlier versions the all have the same,though these different versions are simpler than the earlier versions they all have the 
will mid it so this is goes n goes into m q times n these a remainder r and we are guaranteed that are,arithmetic n goes into n q times and leaves a remainder r and we are guaranteed that r 
are smaller than n otherwise are it could go one more diagonal become plus one right so we have,is smaller than n otherwise r it could go one more time it will become q plus 1 we 
the remainder are which is smaller than for example if i say seven and i want to divide,have the remainder r which is smaller than n so for example if i say 7 and i want to 
a common divisor for both m and n in other words like before we can write n itself a,a common divisor for both m and n in other words like before we can write m itself as 
so is i so if we part this into the question above here right then we see that n which is,so is n if you plug this into the equation above here then we see that m which is a 
as well,well 
the same as before otherwise that are be the remainder in a value,same as before otherwise let r be the remainder with the 
this point one important thing to remember is that r is definitely less than n so we do not,point one important thing to remember is that r is definitely less than n so we do not 
two numbers and we replace m by the remainder and we proceed now we are guaranteed a,two numbers and we replace n by the remainder and we proceed now we are guaranteed that 
so if we go back to example that we were looking at so if we saw that gcd hundred and one two,if we go back to the example that we were looking at so if we saw that gcd 101 2 
number of steps so say billion steps but this or one because of the claim that it takes time to put,of steps say a billion steps but this algorithm because of the claim it takes time proportional 
what programming data structures and algorithms so the programming,is about programming data structures and algorithms so the programming part talks 
need to make sure that this correct and easy to read and maintain so that is the program,to make sure that it is correct and easy to read and maintain so that is the programming 
these idea as but the ideas and says this come from algorithms and data,these ideas but the ideas themselves come from algorithms and data structures  
list from these two list extract the list of common factors and report the largest one,list from these two lists extract the list of common factors and report the largest one 
turn out that these also the largest divisor which is common to m n and m minus n,turn out that d is also the largest divisor which is common to m n and m minus n 
here is the first version of euclids algorithm consider the value gcd of,so here is the first version of euclidã£â€¢s algorithm so consider the value gcd of 
in this common factor are first if we finish an was towards or that we can actually do a single,in this common factor list our first simplification was to observe that we can actually do a single 
of computing the gcd of m and n that we started with we compute the gcd of n and m minus n,computing the gcd of m and n that we started with we compute the gcd of n and m minus 
here is a python implementation of this idea so there are a couple of new features that,so here is a python implementation of this idea there are a couple of new features that 
introduced here so let us look at them the first is this special statement,are introduced here so let us look at them the first is this special statement which 
so comment is the statement that you put into a program to explain what is going on to,so a comment is a statement that you put into a program to explain what is going on to a 
our first and read the program but it is a not by the computer executing the program so,person reading the program but it is ignored by the computer executing the program so 
of n goes to the value of n now it is important that it is simultaneous,value of m goes into the value of n now it is important that it is simultaneous 
worry about having this extra are m to replaced to part one value,worrying about having this extra temporary place to park one value 
is satisfy so now we come to the cut so the algorithm if n divides m,assumed is satisfied so now we come to the crux of the algorithm if m divides n that 
the c will the maximum value of n and the difference as the first argument and the minimum,call gcd with the maximum value of n and the difference as a first argument and the minimum 
value of m and n and make sure that the bigger of the two values,value of n and the difference so it will make sure that the bigger of the two values 
this problem by solving the smaller problem and using that answer in this case directly,this problem by solving the smaller problem and using that answer in this case directly 
but the gcd of m and n insist either we solve the gcd of n and m minus n whatever answer that you,the gcd of m and n instead we solve the gcd n and m minus n and whatever answer that gives 
of the largest common factor we have seen so far in a single name and report it at the,of the largest common factor we have seen so far in a single name and report it at the 
to stopping point so formally what we have to ensure of is that this guarantee of find,a stopping point so formally what we have to ensure is that this guarantee of finding 
have seen so far,we have seen so far 
repeating over this makes to more readable code and in general more interval code makes,repeating over this makes for more readable code and in general more readable code makes 
that a program so what you need to do to write a good programmer first,for a better program so what do you need to do to write a good program well first 
the for you to validated as be correct and for somebody as to understand and if necessary up to,for you to validated as being correct and for somebody else to understand and if necessary 
has a style uses i to make for the most effective and readable code you can find,has a style use the style to make for the most effective and readable code you can find 
if you have a for use it do not force set to use a while and so on,if you have a 'for'  use it do not force as i said to use a while and so on  
that all the factors lie between one and n so this is something we can naturally compute,that all the factors must lie between 1 and n this is something we can naturally compute 
the way we have written is prime it will correctly report that one is not a prime but these are,way we have written isprime it will correctly report that 1 is not a prime but these are 
not seen here so we have three levels of functions stop primes up to which call is prime which,do not see here we have three levels of functions now primesupto which calls isprime which 
nth prime will come an if n is small we might be able to figure out just by looking at,the n th prime will come if n is small we might be able to figure out just by looking 
to check if we have primes and we need a list of all the primes we have c,a time to check if they are primes and we need a list of all the primes we have seen 
of primes is empty so this says take these three values thing three c names an us i,of primes is empty so this says take these three values take three these names and assign 
one and b list is the empty list so this is the same if at this particular assignment,1 and plist is empty so this has the same effect this particular assignment 
simple function which just takes a list of factors factor list of factors,simple function which just takes the list of factors gives back the list of factors 
the value of count and we have found a prime so we must added to the list of primes,the value of count and we have found a prime so we must add it to the list of primes if 
sil number until we hit a count of n so we outside the k for this is an condition,number and until we hit a count of n so we outside if so this is unconditional we 
each time we increment count we are making progress towards this while terminating so remember,each time we increment count we are making progress towards this while terminating remember 
of the input n,of the input n 
and of course we are using fact the implicit fact we know that are an infinite our,of course we are using fact the implicit fact we know that there are an infinite number 
from one to m so it is easy to use a for in n nprimes we do not know how many primes,from 1 to n so it is easy to use the 'for' in nprimes we do not know how many primes 
a while so let us look at the to typical ways in which we write for so the first,by a while let us look at the two typical ways in which we write for the first way 
the statement or limited most it here so this of block of things,this statement or there might be more statements here this is a block of things inside the 
is n does not cross j you execute this statement exact same statement and you increment,as n does not cross j you execute this statement  the exact same statement and you increment 
if it comes back here and we check now,n so it comes back here and you check now you 
j and it links so we have to have range in the for we can just set up a counter and angle,j and it will exit we have a range in the 'for' we can just setup a counter and manually 
so it could have a as many except blocks as you have types of errors switch you anticipate,so you could have as many except blocks as you have types of errors which you anticipate 
it errors for it is not a bigger tree to handle every kind of error only those which,errors for it is not obligatory to handle every kind of error only those which you 
there is an index error,there is an index error 
will be no code executed for a zero division error it is not that i tries each one of,will be no code executed for the zero division error it is not that it tries each one of 
insert will come here nine this is not the type of error,turns that would come here find this is not a type of error 
which are not handled and finally we have an else which will execute if the try terminates,which are not handled and finally we have an else which will execute if the try terminates 
now out while we normally used exception handling to deal with errors switch we do not anticipate,now while we normally use exception handling to deal with errors which we do not anticipate 
we saw got recently that we can use dictionaries in python,we saw recently that we can use dictionaries in python 
with each key which is a name we have a list of scores,with each key which is a name we have a list of scores 
now out suppose we want to add is score to the is,now suppose we want to add a score to this 
this is a new batsman there is no key for b in which case we have to create a key,this is a new batsman there is no key for b in which case we have to create a key by 
i setting scores of b equal to the list containing x right so we have to alternative modes of operation,setting scores of b equal to the list containing s rightwe have two alternative modes of operation 
so we want to append its,so we want to append it 
so we want to distinguish these two cases,so we want to distinguish these two cases 
so we say make enough d is in the scores dot keys if we have b as an existing key then we append,so we say if b is in the scores dot keys if we have b as an existing key then we append 
the key error,a key error 
but it is just emphasizing that once we have exception handling under a control we,but it is just emphasizing that once we have exception handling under our control we may 
may be able to do things differently from what we are use two and sometimes these may,be able to do things differently from what we are used to and sometimes these may be 
would like to do is provide apply hand on how to deal with this exceptional situation an,would like to do is provide a plan on how to deal with this exceptional situation and 
so this is call results and executing this scope and this definition might have that another,so this call results in executing this code and this definition might have yet another 
in each we did not put in a try block and so or the error is not handled,in h we did not put it on a try block and so the error is not handled 
back to whatever called it,back to whatever called it 
then this error because g to abort,then this error will cause g to abort 
so what will happen next is that if g does not handle it then this will go back to,so what will happen next is that if g does not handle it then this will go back to where 
so exception handling asks when something goes wrong how do we provide corrective action,so exception handling may ask when something goes wrong how do we provide corrective action 
of calls high error quickly we can catch it at any point,of calls hierarchically we can catch it at any point 
have from the point it is calling his,up from the point that is calling us 
the program and n says much more prone to errors and therefore useful to be able to,the program and hence is much more prone to errors and therefore is useful to be able 
are all this what we require is a way of capturing these errors within the program as it is running,for all this what we require is a way of capturing these errors within the program as it is running 
not have noticed the subtle t of these for example when we run python and we type something,not have noticed the subtelty of these for example when we run python and we type something 
from a string to an integer but this string s is not a valid representation of an integer,from a string to an integer where the string s is not a valid representation of an integer 
so what we are really it is written is errors that happen invalid programs,so what we are really interested in is errors that happen in valid programs 
that the name is not defined and we also type the code at the beginning of the line say,that the name is not defined and we also get a code at the beginning of the line saying 
gives us an index error or a name error and it says clearly that the name x is not defined,gives us an index error a name error and it says clearly that the name x is not defined 
and along with a message division by zero and finally if we have a list say one two and then,and along with the message division by 0 and finally if we have a list say 1 2 and then 
we ask for the position three then it will say that there is no position three the,we ask for the position three then it will say that there is no position three in this 
flist for this in,list 
let us first quickly set lot some terminology,let us first quickly settle on some terminology 
and as we saw it comes in two parts there is that type of the error what kind of the,and as we saw it comes in two parts there is the type of the error give what kind of 
will be trying to write to a file but the disk is actually for,be trying to write to a file but the disc is actually full 
do is strings last in the previous lecture we looked at other things you can do with string,do with strings last in the previous lecture we looked at other things we can do string 
sil fine entry place an all these things so this is like that is in the same class,like find replace and all this things so this is like that it is in the same class 
the string here is actually going to call a format method so these this way to do,so the string here is actually going to call a format method so the easiest way to do 
is to for a things in braces the funny things and braces are to be caught,two funny things in braces the funny things in braces are to be thought 
talk as the equivalent of arguments in a function these are things to be replaced by actually,of as the equivalent of arguments in the function these are things to be replaced by actual 
the third then the zero o refers to the first argument and one refers to second and it so what,method then the 0 refers to the first argument and 1 refers to the second argument so what 
pass it to python the resulting thing is first colon forty seven second colon eleven because the first,it to python the resulting thing is first colon 47 second colon 11 because the first 
we can do the same thing by name so instead of is exactly like that when a function where,now we can do the same thing by name this is exactly like defining a function where 
however it takes an optional argument end equal to string which changes what we put,however it takes an optional argument end equal to string which changes what we put 
is forty seven and st as in l so here we using the name and not the position so the order in which list,as 47 and s as 11 so here by using the name not the position so the order in which you 
a string and we have two will tell us how to replace values for place holders the string,a string and we have told us how to replace values for place holders in the string there 
is no real formatting just are because whatever we did with that to what,is no real formatting which has happened because whatever we did with that we could have already 
and then a four it so this whole thing this part if it comes from the format so have a blank,and then a 4 this whole thing this part of it comes from the format so i have a blank 
space a blank space four because i do is to old to put for in a new it of three and think a,space a blank space and a 4 because i was told to put 4 in a width of 3 and think of 
from a space whatever we want and in particular if we do not want any spaces we can put the,from a space to whatever we want and in particular if we do not want any spaces we can put them 
and five to three so be treated or floating point value k second thing is that it says,should be treated as a floating point value and the second thing is that it says this 
value including the testing point everything is going to be six characters white finally,value including the decimal point everything is going to be 6 characters wide 
it that for says how many does issue show after the does not point so if i apply all this,finally the 2 says how many digits to show after the decimal point if i apply all this 
now sometimes you want to be a little bit more precise so for this we can use the format,now sometimes you want to be a little bit more precise so for this we can use the format 
can be,can be done  
to supposing we have defined the function square of writes which is returns x times and now,supposing we have defined a function square of x which just returns x times x and now 
x and use been assigned so this is exactly as we said like before the x then,to x and 2 is being assigned to n this is exactly as we said like before like saying 
ways to another to execute the function inside the another function without new,to another place and execute that function inside the another function without knowing 
a b will come before a b because the second position d is smaller than so this will,aab will come before ab because the second position a is smaller than b so this will 
plus one because the if b has length three is known the three so we could write a saw,us plus 1 because aab has length 3 and is longer than ab so we could write a sort 
if you get an if you want to them combine it to the of the,than equal to or greater than then if you want you can combine it with the earlier 
so to summarize function definitions behave just like other assignments so values to,to summarize function definitions behave just like other assignments of values to names 
you can use one function and make it point mean point to another function,crucially you can use one function and make it point name point to another function 
and this is implicitly use when we pass functions to other functions and situations like saw,and this is implicitly used when we pass functions to other functions and in situations like 
which will take a string and try to represented as integer if s is a valid implementation,will take a string and try to represent it as an integer if s is a valid representation 
and this is effectively this thing as adding implicit assignment so when we say power,and this is effectively the same as having an implicit assignment so when we say power 
not a valid number a five would actually generate in a,not a valid number ã£â€™a5ã£â€œ would actually generate an error 
that is not provided and substitute to the default value n,that is not provided and substitute to the default value 10 
now if we to provide a value then for instance we can even make sense of a file,now if we do provide it a value then for instance we can even make sense of ã£â€™a5ã£â€œ 
naive a use infinitely written using a b c so a corresponds to what we would think of the,are usually written using a b c d e f so a corresponds to what we would think 
sixteen position is in the ones so we have sixteen times ten the base ten,sixteenth position and this is the ones position so we have 16 times 10 because the a is 
plus five so you make terms this will return one sixty five there,10 plus 5 in numeric terms this will return 165 correctly 
you want to option and default argument you provide the value when the function definition,you want an optional default argument you provide the value in the function definition 
take the value n otherwise if you take the value provided by the function so the default,take the value 10 otherwise it will take the value provided by the function call the 
than the default value used inside but one thing to remember is that this default,then the default value is used instead but one thing to remember is that this default 
this assignment there and of course that but if you calling it in the function is that,this assignment there and of course the advantage of calling it as the function is that we 
so here is a simple types suppose we have the function with for arguments the b c t and,here is a simple prototype suppose we have a function with 4 arguments a b c d and 
us i will have to t define the function to the order and,not possible i will have to redefine the function to reorder it 
then interprets is like in the other assignment of a value to a to for instance this value,python interprets this like any other assignment of a value to a name for instance this value 
is a neighbor declare you can go and redefine f as two four another,exists and in particular you can go on and redefine f as you go ahead 
which as we said associates with the name f the body of this function at any this,which as we said associates with the name f the body of this function at a later stage 
one dictionary in to another some now y would you want to do is one useful,dictionary to another and so on now why would you want to do this so one useful 
way in which you into this uses facility is to pass a function to another function,way in which you can do this use this facility is to pass a function to another function 
so suppose we want to apply a given function f to its argument n x then we can write,suppose we want to apply a given function f to its argument n times then we can write 
to the second is the argument and the third is the number of times but it should,function the second is the argument and the third is the number of times the repetitions 
give it more meaningful names and then it says that this function takes three values as inputs,give it more meaningful names then it says that this function takes three values as inputs 
have a thing useful to do so we have a function if we call stupid which takes,not have anything useful to do we have a function which we call stupid which takes 
does is it just or no good reason sets the name n to have the value seventy now suppose we had in our,does is it just for no good reason sets name n to have the 17 now suppose we had in our 
program outside or a statement which assign the value seventy to the name n and then we go all the,program outside a statement which assigned the value 7 to the name n and then we call 
function now obviously if we say stupid of a ten the you will be also the input so it will be with even become twenty,this function now obviously if we say stupid of 8 then v will also be the input so v will 
up to different copies of n so any name which is used inside a function is to we think,are two different copies of n so any name which is used in side of function is to be 
we do because is just confusing if we use the same name inside and outside but sometimes,do because is just confusing if you use the same name inside and outside but sometimes 
i j k to run through lists now like ranges up in fact that and it will be a new some,j k run through list you know like ranges and things like that and it will be a nuisance 
or the since is not track anyway we can freely use i j wherever we want,interact since they do not interact anyway we can freely use i j wherever we want and 
is invoked now this is a slightly separate point so less just look at little more so,it is invoked now this is a slightly subtle point so let us just look at it little more 
so when the python program is write it reads the definition of f but does not execute it and no to,the python program is read it reads the definition of f but does not execute it and notice 
a function we might have a statement like this called return so,within a function we might have a statement like this called return 
right so it is so if i put this statement execute f before i define g and f requires in then,statement so if i put this statement execute f before i define g and f requires g then 
this statement will create an error whereas the statement in one,this statement will create an error whereas this statement will not 
function of the scan these are called recursive functions is which are the in themselves,function of this kind these are called recursive functions functions which rely on themselves 
one into n minus two into n down to one so we take n and multiplied by all the numbers,1 into n minus 2 into n down to 1 so you take n and multiply it by all the numbers 
the of a smaller factorial it is n times n minus one factor so that is what this function that,of a smaller factorial it is n times n minus 1 factorial so that is what this function 
a zero and the point is a factor of zero will now terminate and it will give me one to,of 0 and the point is that factorial 0 will now terminate and it will give me 1 because 
a function your code it to smaller functions is much easier to understand to read and to maintain,your code into smaller functions it is much easier to understand to read and to maintain 
that immutable any change within a function does not affect the argument outside also,they are immutable any change within a function does not affect the argument outside also 
a function does not in any way affect the name outside so functions have no low,the function does not in any way affect the name outside so functions have local notion 
functions must be defined before where we use and this is a put reason to,also functions must be defined before they are used and this is a good reason to push 
call a function definitions to the beginning of your program so that the python interpreter,all your function definitions to the beginning of your program so that the python interpreter 
this which takes is x and reason to the power n let us just look at the function just,this which takes x and raises it to the power n let us just look at the function just to 
to understand what the code is doing so we assume that the value of the answer is one and now,understand what the code is doing we assume that the value of the answer is 1 and now 
for as many i as there are in the range zero to n minus one multiply x into on serves so,for as many i as there are in the range 0 to n minus 1 we multiply x into answer so 
form state our three five so obviously what this means is that we should be used for x and find,form say power 3 5 so obviously what this means is that 3 should be used for x and 5 
in use of n and we would and run this code when the values x equal to three and n equal,should be used for n and we would then run this code with the values x equal to 3 and 
a function is a group of statements which performs segment ask so of course we could,a function is a group of statements which performs a given task so of course we could 
this code it is as though we have this code inter insert it into a program at this point preceded,this code it is as though we have this code inserted into our program at this point preceded 
by this assigned in the assignment basically says set the value of the name x to the value,by this assignment so this assignment basically says set the value of the name x to the value 
assignment in the list,assignment in the regular case 
that happens with mutable things like lists in a immutable values will not be affected at,that happens with mutable things like lists immutable values will not be affected at the 
and finally we is the value to be the play,position and finally v is the value to be replaced 
zero an l minus one so it is greater than or equal to zero init strictly less than the line,0 and l minus 1 so it is greater than equal to 0 and it is strictly lesser the length 
one update so what we will do is effectively return false so this is,we cannot do an update so what we will do is effectively return false this is just 
different arguments so the constant you to unit of computation which can be used repeatedly,different arguments so they constitute a unit of computation which can be used repeatedly 
that we would be an immutable value so let us assume call f so what we do,that v would be a immutable value let us assume we call it now so what we use do is 
we set up a list of numbers a list of numbers three eleven or and then we want to replace this well say by eight,we set up a list of numbers 3 11 12 and then we want to replace this 12 say by 8 
for by the value of set now as we saw in the values for right then this if we so we,4 by the value of z now as we saw if the values 4 right then this if will fail so 
what have self so as we expect after executing these for so statements because,what happens to z so as you would expect after executing these four statements because 
that there are a couple of other points to note,the program now there are couple of other points to note 
about this function just to illustrate one is that we have here to return statements it,about this function just to illustrate one is that we have here two return statements 
went through a return false the idea is that the indicate to the calling function where,return true or return false the idea is that they indicate to the calling function whether 
is valid and it will return true or false depending on whether the update succeeded,is valid and it will return true or false depending on whether they update succeeded 
of this then mainly functions which do not return anything useful at a typical example,of this there may be functions which do not return anything useful at all a typical example 
may be no return function so by default what happens is that a function executes like,may be no return function so by default what happens is that a function executes like 
ordered so all this problem the first observation we can make is that if we have a simple,in order to solve this problem the first observation we can make is that if we have a sequence 
to ascending order so we start with a its the smallest one then b and c and so on,in ascending order so we start with a which is smallest one then b and c and so on and 
n and we work backwards down to eight so if we want to find the next permutation me,m and we work backwards down to a if we want to find the next permutation we 
we want to find the log is suffix that cannot be incremented so suffix that cannot be,we want to find the longest suffix that cannot be incremented so a suffix that cannot be 
created is one which is as largest it could possibly t which means is sorted,incremented is one which is as large as it could possibly be which means that it is already 
so if i fix the letter from the to k then this is the largest permutation i can generate,so if i fix the letter from d to k then this the largest permutation i can generate with 
did i cannot incremented within this red box so i must extend this to find the shortest,it i cannot increment it within this red box so i must extend this to find the shortest 
suffix mean sub extract and k where something can be incremented now how do,suffix namely suffix started with k where something can be incremented now how do we 
the position for every queen on every row and if it was tree then we try to doubt and,position for every queen on every row and if it was free then we tried it out and if 
o but o is bigger than j so that we set our here we have a suffix that cannot,than o but o is bigger than k so that means than up to here we have a suffix that cannot 
not be incremented and this is a first position where we can making it,be incremented and this is the first position where we can make an increment 
order so it is in sorted order so we can go through and find the first position,order it is in sorted order so we can go through and find the first position where 
and what we did to the descending order we replace m by k but what is the property of,and what we did to the descending order we replace m by k but what are the property of 
a queen so the row o the column numbers if we re tell row by row the call an the numbers form a permutation,queen the column numbers if we read then row by row the column numbers form a permutation 
so this is a concrete to always to find the next permutation walk backwards,this is a concrete way in all to which find the next permutation walk backwards from 
this suffix if we want to increment of course if we go all the way we go back to,the suffix that you want to increment of course if we go all the way and go back to 
first letter and we have not found position and we what we reach the,the first letter and we are not found such a position then we have already reached the 
last permutation in the overall scheme things,last permutation in the overall scheme of things 
position this case m to swap with k after swapping it we take the suffix after the,position in this case m to swap with k after swapping it we take the suffix after the new 
you letter we put queen the n and we reversed you get the smallest permutation starting with,letter we put namely m and we reverse it to get the smallest permutation starting with 
of zero to n minus one so keys number zero to n minus one it is exactly once as a column,of 0 to n minus 1 so each number 0 to n minus 1 occurs exactly once as a column number 
old which squares are under attack and placing the queens one by one,which squares are under attack and placing the queens one by one 
so why we are topic of global scope python allows us to define functions within function,while we are on the topic of local scope python allows us to define functions within 
and now we can now update x for instance y then says by column g of x procedure fixed rather than,now we can update y for instance by calling g of x plus h of x rather than just setting 
f so then inside f right so then inside f an hence they are not visible outside,so they are inside f and hence they are not visible outside 
now by default python is scope this local to a function we saw that if we use a name inside,now by default in python scope is local to a function we saw that if we use a name inside 
score so it will be as an this is a possibly,exposed to everybody else and this is a possibility 
a h so if you look up the next say the first side and it is not then n,so if we look up an x here it will first try to look up f if it is not there in f 
either we can declare global in which case you can update within g or h or not,so either we will declare it global in which case we can update it within g or h or it 
inside f but not to the value outside,value inside f but not to the value outside f 
into the function and make it updatable within a function,in to a function and make it updatable within a function 
in the name what now the question is what is the set,name y now the question is what is this x 
square there is an x here you,well there is an x here 
code so we have from,code 
one dot file a sec star assignment x equal to twenty two inside,to f 1 dot py is extra assignment x equal to 22 inside f 
at this point inside,at this point inside f 
the illegal look up the outside x it written says that there is an inside x in l,willing to look up the outside x it will insist that there is an inside x 
the x is not found in f python is delete to look at the enclose in function for a,so if x is not found in f python is willing to look at the enclosing function for a global 
like this,x 
however if texts this updated in f then it becomes a local name and then it gives and or,however if x is updated in f then it becomes a local name and then it gives an error 
element of x we,element of x to 22 
here we have this function in which we now k and x from integer to a list and the,here we have this function in which we now changed x from an integer to a list and then 
we try to assign it,we try to assign it in y 
so global names that point immutable values can be updated,so global names that point to mutable values can be updated within a function 
a passing the board around it is inside the queens actually requires no further exploration,avoid passing the board around with its inside 8 queens actually requires no further explanation 
all the definitions so that board as in the current works hand,so that board does not occur and works fine 
is going to look for the value which is defined outside namely this empty dictionary,going to look for the value which is defined outside namely this empty dictionary 
so a is that for our purpose which is to fix that eight queens problem without having to,so as we said for our purpose which is to fix that 8 queens problem without having to 
being an integer,outside the function 
this brings us to a concept of scope,so this brings us to a concept of scope 
this is a way of telling python do not confuse is x equal to t would twenty two with create,this is the way of telling python do not confuse this x equal to 22 with creation of 
should of a new local name x,a new local name x 
all x is refer to in at are actually the same as the x outside and we treated a,all xã¢â‚¬â„¢s referred to in f are actually the same as the x outside and to be treated as 
program,a python program 
spot set to twenty two inside f,x got set to 22 inside f 
so we expect the second print statement give us twenty two,so we would except the second print statement to give us 22 
so if we run this in the this is what we see that if we have to lines the first says,so if you run this indeed this is what we see right we have two lines the first 7 comes 
than naive recursion and we saw memoization and dynamic programming as to is to do this,than naã¢â‚¬â¢ve recursion and we saw memoization and dynamic programming as tools to do this 
a unique a while so this gives us a simple inductive formula,in a unique way to (i j) this gives us our simple inductive formula 
me ways can and go from zero and just names into a zero and there is only one that it is tempting to say,many ways can i go from (0 0) and just stay in (0 0) well there is only one way it 
along the left column right the moving on the left column then they are no paths can,along the left column if you are moving along the left column then there are no paths coming 
ways there are to go from the bottom left corner to the top right comp so we want,ways there are to go from the bottom left corner to the top right corner so we want 
the all to is set of roads so pathsi i zero can only come from the left from paths,we are already on the lowest set of roads so paths(i 0) can only come from the left 
the add an extra clause which says pathsi i b j zero if this of whole it i j otherwise,just add an extra clause which says paths(i j) is 0 if there is a hole at (ij) otherwise 
n in the for ten and five time but in turn in order to compute for ten i will have to,10) namely (4 10) and (5 9) but in turn in order to compute (4 10) i will have to 
we need to compute one we first check the table if it is already there to look it up,we need to compute one we first check the table if it is already there we look it up 
are that the base value at zero is one k and now once we have done this it,remember that the base value at (0 0) is one and now once we have done this it turns 
in these two unknown so i can add them not remember the sum of the value,then these 2 are known so i can add them up remember the value at 
any position is just the value to its left plus the value which bottom and now i start with the,any position is just the value to its left plus the value to its bottom and now i start 
here is one path wrong do,so here is one path drawn in blue 
that means that no path actually allowed to propagate through that are,that means that no path is actually allowed propagating through that row 
in the wrong direction so here for instance we have only six paths coming from the left,from the wrong direction so here for instance we have only 6 paths coming from the left 
the different path on right and notice that these two paths actually star,here is a different path drawn in red and notice that these 2 paths actually start 
you should get the same answer there is a third way to do this,we should get the same answer there is a third way to do this 
first element to its right so we can do this dive now notice that any diagonal,first element to its right so we can do this diagonal now notice that any diagonal 
this table in an iterative fraction not recursively we want to all f of five j and then,table in an iterative fashion not recursively we do not want to call f of i j and then 
entry but the values we need to coming multiple different orders so we,we need but the values we need could come in multiple different orders so we could 
are diagonal but it does not matter so long as we actually get all the values that we need,it diagonally but it does not matter so long as we actually get all the values that we 
the price because whenever you make a recursive call you have to suspended computation install,price because whenever you make a recursive call you have to suspend a computation store 
in the grid path ing there is one situation where you can illustrate this imagine that,in the grid path thing there is one situation where you can illustrate this imagine that 
to reached this it is very clear that i can only come all the way along the top o or all,to reach this its very clear that i can only come all the way along the top row or all 
we come back and recursively explore it will never ask has come here because it never,we come back and recursively explore it will never ask us to come here because it will 
we pass number of entries so n squared is much larger than two and remember so it,computing a vast number of entries so n squared is much larger than 2n remember it will take 
flip side is that each entry that we need to add to the memo table requires one recursive of,flip side is that each entry that we need to add to the memo table requires one recursive 
is to make these are can write moves the question is how many total such different paths,to make this up and right moves and the question is how many total such different paths are 
is just to determine how many moves we have to make we have to go from zero to five and,is just to determine how many moves we have to make we have to go from 0 to 5 in one 
direction and zero to ten and the other direction so we have to make a to the number of five horizontal,direction and 0 to 10 in the other direction so we have to make a total number of 5 horizontal 
is steps and ten must be vertical steps because they all take us from zero to,horizontal steps and 10 must be vertical steps because they all take us from (0 0) to (5 
first to make an up move then we make a right then we make an up move make another node,first we make an up move then we make a right move then we make an up move then make another 
and if we fix the five right moves then automatically all the remaining slots must be ten up or comma,and if we fix the 5 right moves then automatically all the remaining slots must be 10 up moves 
worst right so it is either fifteen choose find it is the way of choosing,or conversely it is either 15 choose 5 it is the way of 
of fifteen choose five is clearly the same is fifteen choose ten because we could also fix the ten up moves,of 15 choose 5 is clearly the same as 15 choose 10 because we could also fix the 10 up moves 
much to compute are that then writing out large factorials and then seen what the none,much to compute other than writing out large factorials and then seeing what the number 
so we can count these bad paths and subtract then the good paths code we come,so we can count these bad paths and subtract them from the good paths how do we count 
the bad paths well we can the solve a smaller version that so we have an intermediate,the bad paths well we can just solve a smaller version of the problem so we have an intermediate 
we have to or how many passed to from that to the right so from zero to two four we get,here to here how many paths go from here to here so from (0 0) to (2 4) we get 
fifteen and from here to here the difference is that we have to do in both directions three n,15 and from here to here the difference is that we have to do in both directions 3 and 
ways in the bottom can be act combined with a we and the top so we multiply this and,ways in the bottom can be combined with a way on the top so we multiply this and we 
count all the paths which get block because of the first intersection we can get count all,count all the parts which get blocked because of the first intersection we can count all 
so we can count all these paths which pass through for four so this we know,been blocked so we can count all these parts which pass through (4 4) this we know how 
let us look at the inductive structure of the top suppose we say we want to get,let us look at the inductive structure of the problem suppose we say we want to get 
it one step to a intersection i comma j how then we reach this one step since power roads,in one step to intersection (i j) how can we reach this in one step since our roads 
another words if we say that pathsi i j is the quantity if we want to compute we want,in other words if we say that paths(i j) is the quantity we want to compute we want 
to count the number of paths from zero is you to i j these paths has break up into two disjoint,to count the number of paths from (0 0) to (i j) these paths must break up into 2 disjoint 
in the last lecture we saw how to use the input and print statements to collect input,in the last lecture we saw how to use the input and print statements to collect input 
so backslash n is a notation which then nodes a single character even though it looks like took,the backslash n is a notation which denotes a single character even though looks two characters 
so in other words if you are going to transfer this from one file to another in order to,in other words if you are going to transfer this from one file to another you do not 
worry about reinserting backslash n because is already,want to worry reinserting the backslash n because this is already there 
in that you have a large storage facility in which is to or things in b cartons,imagine that you have a large storage facility in which you store things in big cartons 
we could of a line which of hundred characters next line to three characters and so on so,so we could have a line which has 100 characters next line could have 3 characters and so on 
everything up to that backslash n will be returned as the if i to a string return by readline,everything up to the backslash n will be returned as the effect to a string return by the readline 
in case we want to actually divert from the strategy there is a command see it which takes a put,in case we want to actually divert from the strategy there is a command seek which takes 
finally we can modify the read statement to not read the entire file but to re,finally we can modify the read statement to not to read the entire file but to read 
fh dot read ten it will read the next and number and keep going and this,so if we say fh dot read 10 it will read the next pan number and keep going and this 
will say new some space along,will save you some space in the long run 
so if you are reading will a file line by line then we may want to know when the file is ended,so if you are reading a file line by line then we may want to know when the file has 
so one is if we try to read using the read command and we get nothing back we get an,so one is if we try to read using the read command and we get nothing back we get an 
k in the return the empty string it means that we have reached,so read or readline if they return empty string its means that we have reached the 
so right takes an argument which is a string,so write takes an argument which is a string 
so this takes a list of strings and writes them one by one into the file,so this takes list of strings and writes them one by one into the file 
sit to the file pointed to by the file handle an,it to the file pointed to by the file handle 
dot close,they are flushed 
are copied out to the disk,copied out to the disk 
it also now means that if it is no longer associated with the file we are dealing with,it also now means that fh is no longer associated with the file we are dealing with 
print,print 
in all on to the disk do not way for the rest right stuck you will a handle the buffer is full,all on to the disk do not wait for the risk drives to accumulate until the buffer is full 
and then write as you normally would to the disk,and then write as you normally would to the disk 
here is a typical thing that you would like to do in python which is to process it line,here is a typical thing that you would like to do in python which is to process it line 
for each line that by read from the list infile dot readlines i just write it to outfile,so for each line that i read from the list infile dot readlines i just write it to outfile 
right so instead of saying for each line in infiles get i can just write it directly out,so instead of saying for each line in infiles i can just write it directly out 
if,annoyance 
the line preparing visible to us so the,the line because they are invisible to us 
a spaces and tabs and if there at the end of the line we do not the line ends with a large,spaces and tabs and there at a end of line we do not know the line ends with the last 
character we see of there are spaces are,character we see there are spaces after words 
it will also strip other chunk there is some spaces and tabs for the backslash n an,it also strips to other jump there is some spaces and tabs before the backslash n and 
return that,return that 
we also strip from the left using l strip or we can strip on both size if we just,we can also strip from the left using l strip or we can strip on both sides if we just say 
now let us open that python interpreter and try to read lines from this file and but it,now let us open the python interpreter and try to read lines from this file and print 
now y is there a blank line between every line in a file that is because when we readlines,now why is there blank lines between every line in our file that is because when we readlines 
so the quick brown the first line it will backslash n fox sides a backslash n,so the quick brown the first line end with the backslash n fox end with backslash n 
this is like getting access to a buffer from which data from that file can be rid into memory,this is like getting access to a buffer from which data from that file can read into memory 
only way that we can undo this is to start again by closing the file,the only way we can undo this is to start again by closing the files 
so this close the file,this closes of the file 
now having open this file handle everything we do with the file is actually done,now having opened this file handle everything we do with the file is actually done with 
fh dot readlines,f dot readlines for each line 
an input dot txt t r as before stage easy open output dot txt think of it and now,input dot txt r as before and we say g is equal to open output dot txt w and now we 
not if you look at the lines the quick brown fox its it up now for example cycle i,turn out if you look at the lines quick brown fox etcetera for example the second line 
it is just fox as three letters but if we put the backslash n itã•s wrote for letters so the,is just fox fox has three letters but if you include the backslash n its wrote 4 letters 
summarize what we have seen is that if you want to interact with files we do with root,to summarize what we have seen is that if you want to interact with files we do it through 
so we do not directly try to read and write from the disk in set we write and read and write from,so we do not directly try to read and write from the disk instead we read and write from 
memory m the file on the disk,the memory and the file on the disk 
we saw that we have a read readline and readlines so using this we can either read the entire file in,we saw that read readline and readlines using this we can read the entire file in 
one shot is a string or it line by line,one shot of the string or read it line by line 
similarly we can either write a string or we can write a list of strings to,similarly we can either write a string or we write a list of strings too 
so we have a write command in a writelines and writelines is more correctly to be interpreters,so we have a write command in a writelines and writelines are more correctly to be interpreters 
buffer by using the flush command and we also saw that there are some string operations,buffer by using flush command and we also saw that there are some string operations 
an with a processing we need to make sure that all the data that we have written goes back,with our processing we need to make sure that all the data that we have written goes back 
the data on to write to the file is actually taken out of the buffer and put on to that,any data we want to write to the file is actually taken out to the buffer and put on to the 
is and this is technically called flushing the buffer,disk and this technically called flushing the buffer 
the first argument that you give open is the actual file name one you are disk,the first argument that you give open is the actual file name on your disk 
the first part and extension,first part and an extension 
are or directly very a running the script,or directory where you running the script 
so you can give a file name which belongs to a different part if your,so you can give a file name which belongs to the different part of your directory hierarchy 
on windows or unix or what operating systematic,on windows or unix what operating system you are using 
so for large data we a for studied with files which reside on the disk,so for large data we are forced to deal with files which reside on the disk 
so what we have to do is decide in advance with of we are going to read from a file,so what we have to do is decide in advance whether we are going to read from a file or 
so we have to read a large volume of data which is already written a file that,so we have to read a large volume of data which is already written on a file in the 
append to do is that it will take a file which already exists and add the new stir,what append will do is it will take a file which already exists and add the new stuff 
disk and the output we compute is typically written back into another file on the disk,disk and the output we compute is typically return back into another file on the disk 
the name contents,the name contents 
so contents is now assigned the end type up data which is in the file handle pointed to by a fetch,so contents is now assigned the entire data which is in the file handle pointed by fh 
now we can also consume a file so we have typically dealing with text files,now we can also consume a file we are typically dealing with text files 
that returned is that transmitted by input as a string to the name that you assigned to the,the return is then transmitted by input as a string to the name that you assigned to 
so readline is like that but the difference between readline an input is that,so readline is like that but the difference between the readline and input is that when 
are so you have to remember that you have this extract character floating and the n,so you have to remember that you have the extra character floating around at the end 
a for loop has a fixed number of repetitions on the other hand while loop is typically,so for loop has a fixed number of repetitions on the other hand a while loop is typically 
one to the larger of m and n and in one scan compute list fm and fn,1 to the larger of m and n and in one scan compute list fm and fn 
do it again so if you are not changed something which makes the condition false we will never,do it again if you have not changed something which makes the condition false you will never 
now previous example in order to make the condition false we need i to become,in our previous example in order to make the condition false we need to i to become 
have a dangerous kind of behavior called an infinite loop where the computation just see,have a dangerous kind of behavior called an infinite loop where the computation just keeps 
in other words for each i in this list one to the maximum of m and n if first check if,in another words for each i in this list 1 to the maximum of m and n we first check if 
in this lecture what we have seen is that we can start with a very naive idea,so in this lecture what we have seen is that we can start with a very naive idea which 
is more or less implements the function as it is defined and work are ways to dramatic,more or less implements the function as it is defined and work our ways to dramatically 
will run through all these values anyway because we scan all these numbers in order to find,will run through all these values anyway because we scan all these numbers in order to find 
i can actually come up to the dramatically a different way to compute gcd which will,we can actually come up with a dramatically different way to compute gcd which will be 
n and if so we add to the list n so instead of to two separate scan through a one to m and the,n and if so we add it to list fn instead of doing two separate scans over 1 to m and 
you while the else,new ideas 
says that we want to conditions to be true we want the remainder when n is divided by i,says that we want two conditions to be proved we want the remainder when m is divided by 
be zero in other words i divides m and we also want the remainder when n is divided,i to be 0 in another words i divides m and we also want the remainder when n is divided 
each time we can start with one in each time we find the larger common factor we can discard,each time we can start with 1 and each time we find a larger common factor we can discard 
updating this name with the value of the common factor that we saw last,updating this name with the value of the common factor that we saw last 
directly scanned all the possible common factors from one to the minimum of m and n whenever,directly scan all the possible common factors from 1 to the minimum of m and n whenever 
one is a common factor we will at least have mrcf equal to one but if we,since one is the common factor we will at least have mrcf equal to 1 but if we find 
of factors in both list for common factors and our goal is to return the greatest common,of factors in both lists or common factors our goal is to return the greatest common 
is for iteration or loop what we end up with is the largest common factor that,this for iteration or loop what we end up with is the largest common factor that we 
found between one and the minimum of m and n which is indeed the gcd of m and n,found between 1 and the minimum of m and n which is indeed the gcd of m and n 
we can such an do some further optimizations since we are looking for the largest common factor,we can still do some further optimizations since we are looking for the largest common 
we can start at the end of the list and work backwards so instead of running from one to the,we can start at the end of the list and work backwards instead of running from 1 to the 
the guarantee is that one will always to upper is a common factor so if there are no,the guarantee is that the 1 will always show up as a common factor so if there are no 
of common factors and the very end we will find one as the greatest common factor,other common factors at the very end we will find 1 as the greatest common factor 
a within backwards from largest to smallest the very first common factor we find must,we are working backwards from largest to smallest the very first common factor we find must 
when we actually get into formal python that us explore a new way of going through a list of values,when we actually get into formal python let us explore a new way of going through a list 
the implicitly exit from this function b time c or return statement in a,found and we implicitly exit from this function every time you see a return statement in a 
i to i minus one take the current value of i subtract one and replace it and n the math matter,i to i minus 1 take the current value of i subtract 1 and replace it in i the mathematical 
equality is written as double equal to this is what we use in our can,equality is written as double equal too this is what we use in our conditions 
many other programming languages means assign a value to be so this is the find,many other programming languages means assign a value to a variable so this is the final 
well at each down to whatever we doing we are inserting a new value into a sorted second,well at each round what are we doing we are inserting a new value into a sorted segment 
of length k,of length k 
a sequence of length one we insert a value into that to get a sorted length,of sequence of length one we insert a value into that we get a sorted sequence of length 
n square sort,n square sort 
suppose into it the other way suppose we take a list which is already sorted,so suppose we do it the other way suppose we take a list which is already sorted and 
now we ask it to sort it then it comes back instant,now we ask it to sort then it comes back instantly 
can either be bigger than the to we saw which,it can either be bigger than the two we saw before 
so each insert step takes only one iteration,so each insert step takes only one iteration 
it does not have to go through anything beyond the first element in order to stop insert,it does not have to go through anything beyond the first element in order to stop the insert 
seven,step 
actually if we take even a large value like ten thousand a reason hundred thousand the should work then so insertion,so actually if we take even a large value like 10000 or even 100000 this should work 
sort when you already have a sorted list will be quite fast because the insert,insertion sort when you already have a sorted list will be quite fast because the insert 
in a sequence and with no prior knowledge about what this sequence looks like it,in a sequence and with no prior knowledge about what the sequence looks like it will 
so what we do is we scan from top to bottom and so an that smaller than the paper,so what we do is we scan from top to bottom and so longer if it is smaller than the paper 
stack we are building,stack we are building 
so what we do with this same list that we had for selection sort is we will pick a,so what we do with this same list that we had for selection sort is we will pick up 
now eighty nine is bigger than both so a key button top of the stack the right end fifty file i have,now 89 is bigger than both so i keep it on top of the stack at the right end 55 i have 
nine so to so left or way to nine then i look at seventy four it smaller than seventy four goes to,so it goes to the left of 89 then i look at 74 it is smaller than 74 it goes to the 
left of them,left of that 
fifty five,55
we start building a sort sorted sequence of one element pick up the next unsorted element,we start building a sort sorted sequence with one element pick up the next unsorted element 
and insert into the correct place into the already sorted sequence,and insert it in to a correct place into the already sorted sequence 
is one and there is some positions so that up to this point everything is sorted,1 and there are some positions so that up to this point everything is sorted 
at each time we look at the value at actually,and at each time we look at the value at 
the slice is a slice a minus one so it,actually the slice is up to sliceend minus 1 sorry 
we look at the value immediately after that which are will be the position called sliceend and,we look at the value immediately after that which will be in the position called sliceend 
give exchanged it that means that this value as now one here,now if you have exchanged it that means that this value has now gone here 
now we again a compare it to the previous value and if it is smaller we exchange,now we again a compare it to the previous value and if it is smaller we exchange it 
so again this means that it goes one more position so,so again this means that it goes one more position 
now net pick the second paper from the old stack and we look at its marks as compared,now we pick the second paper from the old stack and we look at its marks as compared 
is nothing happens so the,so nothing happens 
now we will compare fifty five to the value to its left and there is no change,now we will compare 55 to the value to its left and there is no change 
similarly we will take twenty one right and we compare it to eighty nine says twenty one is smaller than,similarly we will take 21 right and we will compare it to 89 since 21 is smaller than 
than fifty five it will swap since twenty one is smaller than thirty two to swapped but now the position,than 55 it will swap since 21 is smaller than 32 it will swap but now the position 
will get so it swapped and now the position is zero,sorry will swap and now the position is 0 
its left,its left right 
until we put zero ninety nine so when this its ninety nine then this for loop,so in this way we will keep going until it will be 0 0 99 so when this hits 99 
we exit and we go to one hundred zero and b zero one zero,then this for loop will exit and we go to 1 so i will get 0 1 0 and to 0 1 90 
python in python to the output of map is not a list so you need to use,between python 3 and python 2 the output of map is not a list so you need to use 
this is a this one let us to the python going to fill use the we want x y to x in range one to,now let us do the pythagorean triple one we said we want x y z for x in range 100 
of the come and particular you shifts we internally stages or which are in will be,come in particular you should see in the early stages somewhere things which we are 
see three four five right so you sort before writes three four five but you will also see laid,you see 3 4 5 so we saw 3 4 5 somewhere  so 3 4 5 but you will also see later 
so here is the earlier definition of f of the list that we had x y and z and turns,here is our earlier definition of pythagoras where we had x y and z unconstrained so 
is you only get one copy of things like before sixty three four five the,is less than equal to z you only get one copy of things like 3 4 5 so you see 3 
so here is initialization which says l consists,so on here is an initialization which says l consists 
then we copy this is four times the four so we say the actual matrix l as,and then we copy this list 4 times in the four rows we say that the actual matrix l 
as four copies of zero list now we go and change one entry say we change entry one in,has 4 copies of zerolist now we go and change one entry say we change entry 1 in row 1 
want to use it to the list we must use the list function to converted and this,want to use it as a list you must use the list function to convert it and this is 
you expect is the output of this,expect is the output of this 
we have zero list and then we say l is copies of the list for the in,there we have the zero lists and then we say l is 4 copies of zerolists for j in 
so to summarize map and filter and then useful functions to and writing,to summarize map and filter are very useful functions to manipulating lists and python 
sort a list computation is to correctly initialize then it and in the list,for list comprehension is to correctly initialize 2 dimensional or multi dimensional lists to 
a can be used in for functions it but if you want to use them as this a value,they can be used in for functions but if you want to use them as lists and manipulate 
the list of primes we want is empty and now we run through the number list and for each number,list of primes we want is empty and we run through the number list and for each number 
false in case discard,if it is false it gets discarded 
in that can be done using the computation all filter and then so filter first gives us,that can be done using a combination of filter and then map filter first gives us the 
if i that this is the a more that the x y insert a the lengths of the you sides and a for expect,x y and z are the lengths of the two sides and the hypotenuse respectively then x square 
use values are below n such that x y and z form of by paper into six,z whose values are below n such that x y and z form a pythagorean triple instance 
together all possible permutations then we take of those formulation is satisfy,put together all possible combinations then we take out those combinations to satisfy 
so python has a built in function map which has the size that this so in map f l applies f,python has a builtin function map which does precisely this so map f l applies f 
manipulating step to combine them into a single triple x comma right,and then there is a manipulating step where you combine them into a single triple x comma 
of building a new set from existing sets so what python the as a new other languages also,are building a new set from existing sets so what python does and many other languages 
is for i in any l four,like a 'for' then we will apply a filter to it which 
in that range so is a little bit more complicated than the one we did before,in that range it is a little bit more complicated than the one we did before where we only 
so far we have seen some basic types of values in python,so far we have seen some basic types of values in python 
so this is the sub list of this list two comma list thirty seven which gives us just the list that we have,this is sub list of this list 2 comma list 37 which gives us just the list 37 we have 
we say a in python notation is that lists are mutable so mutation is to change,what we say in python notation is that lists are mutable so mutation is to change 
the other parts,the other parts 
then the list nested the saying name now has a seven in place of the value for if i say nested,then the list nested the same name now as a 7 in place of the value 4 if i say nested 
so strings are used to represent text a string is of type str,so strings are used to represent text a string is of type str 
is a sequence of characters an,it is a sequence of characters 
now these change x to seven the question is choose y five how y seven and indeed wise to five an,now we change x to seven the question is it is y 5 or y 7 and indeed y is still 5 and 
as we saw the value of y actually did not change and the question is why should it change,as saw the value of y actually did not change and the question is why it should change 
it turns out that for mutable values assignment does not make a fresh copy lie,it turns out that for mutable values assignment does not make a fresh copy 
is what has happened to list two is list two the same as before namely one three five seven,the question is what has happened to list2 is list2 the same as before namely 1 3 5 
if we say s square bracket i for a string value s then we get the i ith position use,if we say s square bracket i for a string value s then we get the ith position using 
list two is indeed one three five seven,list2 is indeed 1 3 5 and 7 
in this numbering convention an,this numbering convention 
to either name if we happen to update immutable value the other name is also effect,through either name if we happened to update the mutable value the other name is also effected 
similarly if we leave out the last position like this then we will implicitly assume,similarly if we leave out the last position like this then we implicitly assume that 
the last position the slice is the length of this to list of the string and so it goes,the last position the slice is the length of this list of the string and so it goes 
we leave out both position we just put the learned nothing before nothing after logically,if we leave out both position we just put colon with nothing before nothing after logically 
that these lies creates a new sub list,that each slice creates a new sub list 
so what we have is that l we just a colon after it is not the same as x and,so what we have is that l with just a colon after it is not the same as l it is the new 
one which makes then both,list1 which makes then both 
remember if i do not have this then i will get list one and list two pointing to the same,remember if i do not have this then i will get list1 and list2 pointing to the same actual 
so therefore after this list one and list two are disjoint from whichever any update to the,therefore after this list1 and list2 are disjoint from each other any update to list2 
the length of a string using the len function and we said that we will look at more complex,the length of a string using the len function and we said that we will look at more complex 
a list one three five seven and give it the name list two,list 1 3 5 7 and give it the name list2 
so they happen to have the same value but they are two different things and so if,so they happen to have the same value but they are two different things and so if we 
so if we update list three or we update list two there will continue to remaining to,so if we update list3 or we update list2 they will continue to remain equal 
underline object that we have referring to by this name is the same,underline object that we are referring to by this name is the same 
list in the memory,list in the memory 
we have another keyword in python called is,we have another key word in python called 'is' 
this so when we say x is y what we are asking is whether x and y actually pointing,so when we say x is y what we are asking is whether x and y actually point to the 
to the same thing is list,point to the same thing is list2 
now we ask whether list one is equal to list two and neat initial if we ask whether list,now we ask whether list1 is equal to list2 and it indeed is true but if we ask whether 
are decimal point,decimal point 
if we ask whether list two is equal to list three is two that is the case that first list three,if we ask whether list2 is equal to list3 is true that is the case because list3 is 
is list two in the sense that they both are the same physical is and so when we updated list,list2 in the sense if they both are the same physical list and so when we updated list3 
x strings we can combine list if there are using the plus operate,like strings we can combine lists together using the plus operator 
always produces a new list,always produces a new list 
so if we say that list one is one three five seven and then we copy this list as a name to list two,if we say that list1 is 1 3 5 7 and then we copy this list as a name to list2 
is one,to list1 
if on the other hand we reassign list one to be the old value of list one plus a new value nine,if on the other hand we reassign list1 to be the old value of list1 plus a new value 
this x to,9
a slice,taking slice 
time we apply plus me actually did a new list,each time we apply plus we actually get a new list 
is values need not be of a uniform type we can i makes list consisting of list one we nx,these values need not be of a uniform type we can have mixed list consisting or list 
row almost always we will encounter list where the under lies content of the list is of,although almost always we will encounter list where the underline content of a list is of 
position will actually typically have a uniform type but this is not required that python,so all position will actually typically have a uniform type but this is not required by 
and we can nest still is,python and we can nest list 
new feature of python which we introduced that list is a concept of a mutable value,one new feature of python which we introduced with list is a concept of a mutable value 
is so updating x as an affect y and by symbols a,so updating x does not affect y and vice versa 
check whether two names are equal to only value or also are physically pointing to the say,whether two names are equal to only in value or also are physically pointing to the same 
so we can now extract values at the given position or we can extract slices,so we can now extract values at a given position or we can extract slices 
so len of names is three because there are one two three values in a so remember,so len of names is 3 because there are 1 2 3 values in names 
is one difference between list and strings and what we have seen so far,there is one difference between list and strings and what we have seen so far 
of length one we get the same thing,of length 1 we get the same thing 
if we ask for the zero th position then this gives us the letter h,and if we ask for the 0th position then this gives us the letter h 
single value and here we have a list and therefore these two things or not equal to which are,single value here we have a list and therefore these two things are not equal to each other 
and a slice of length one,and a slice of length one 
and nesting so for example we can have a nested list so the,for example we can have a nested list 
says position zero or,this is position sorry position 0 
two one is a single simple value an integer zero an integer for position zero is a list which,position 1 is a single simple value an integer 0 an integer 4 position 0 is a list which 
and nested then as we said we get this value and this value consist of a list itself contain,in nested then as we said we get this value and this value consist of a list itself containing 
is position which is this string and in that we look for the third character which is zero,0th position which is this string and in that we look for the third character which is 0 
so we get the list containing the list thirty seven so node,and so we get the list containing the list 37 
of these using memorization and dynamic programming,of these using memorization and dynamic programming 
be the same,be the same 
if we walk down from that magical value the largest value and we follow the sequence,if you walk down from that magical value the largest value and we follow the sequence 
then we can read often the corresponding the row or column because there same the actual,then we can read of and the corresponding row or column because they are the same your 
program then the memo table and them dynamic programming almost comes out automatically,program then the memotable and the dynamic programming almost comes out automatically 
are two words became un be you initialize the this or l see them you thing at the boundary the nth row and the,two words u and v you initialize this lcw thing at the boundary at the nth row on the 
a much more useful problem in practice than the longest common subword is what is fall,a much more useful problem in practice than the longest common subword is what is called 
it so a look for the next match right so i skip but and x match must come to my right so it must,so i look for the next match i skip but the next match must come to my right it must 
answer and look for these a clever connections but it turns out that is a much more direct,answer and look for these clever connections but it turns out there is a much more direct 
grid to the longest word in secret itself the longest subword that is common is the were,secret is the longest word in secret itself the longest subword that is common is the 
this is the good way of comparing one version of a file,and this is the good way of comparing one version of the file with other version of 
as n and the itself changes then diff else to quickly what are the differences is to,so they had made some changes then diff tells you quickly what are the differences between 
top,problem 
fill it a zero to n minus one is the first word b zero to be n minus one and second word,this last so a 0 to a n minus 1 is the first word b 0 to b n minus 1 is the second word 
and add this i can extended solution by saying the a zero matches b zero one that,and add this i can extend that solution by saying a 0 match is b 0 and then whatever 
is some kind of a matching it says that the now a if you say that the this matches this,is some kind of a matching it says that you know it will say that this matches this and 
which i can do this is the longest common sub seek,way in which again to do this is a longest common subsequence 
the best solution did not match these supposing you claim that the best solution,supposing the best solution did not match these supposing you claim that the best solution 
zero matches b zero so the first two letters are the same i might is will go with that an,a 0 matches b 0 the first two letters are the same and might is well go with that and 
a two sub problems we say ok let us assume be zeroes not part of the solution then the does,two sub problems we say let us assume b 0 is not part of the solution then the best 
so we are looking it examples of problems where the main target is to identify the inductive,so we are looking examples of problems where the main target is to identify the inductive 
subword this as length three and if we have to very different words like director unset grid,subword in has length 3 and if you have two very different words like director and secretary 
us in general will take us deeper in the words we said easy a zero b zero which require solved,this in general will take us deeper in the words so we said a 0 b 0 will require solved 
a i and solve it and take the but of the right we take max of some solution from i an this,a i and solve it and take the better of the two we take max of the solution from i and 
you can fill up the bottom row and the leftmost column there are the right moves for now,we can fill up the bottom row and the left most column there here the right most column 
is column by column and we propagate it and then finally if,column and we can do this column by column and we propagate it and then finally the 
green increment the number so we can ask why is this four so we say that this is for because not because we did,the number so we can ask why is this 4 so we say that this is 4 not because we did 
one plus three because s is not equal to be we before because we got the max value from here,plus 3 because s is not equal to b we did 4 because we got the max value from here 
wise is for again i is not equal to s so we got the max value of y is this,why is this 4 again i is not equal to s so we got the max value from here why is this 
this and a explanation of the longest number is number or an these diagonals,this kind a explanation of the longest number largest number we got and each diagonals step 
by following stop,by following this path 
its initialize the last row and the bottom row in the last column and then as before,just initialize the last row and the bottom row on the last column and then as before 
is a brute force algorithm that you use which is to just start at i n,there is a brute force algorithm that you could use which is you just start at i and 
in go before you find the or not so you match a i and b j right so if a i and,can go before you find they are not so you match a i and b j right so if a i and b 
from b j plus one and so on and whenever we find to pair two letters which differ then the commons so,plus 1 b j plus 1 and so on and whenever we find two letters which differ then the commons 
in general i start at i j and then i have to go from i till the end and from j to the end,in general i started i j and then i have to go from i to the end right and from j to the 
it or a i is equal to b j so i get one plus two and the base case of the bound,letter a i is equal to b j so i get one plus that and the base case of the boundary 
the condition is well one of the two words empty if i have no letters left if i,condition is when one of the two words is empty right if i have no letters left if 
column i j and in a different combinations i and j either i or j,i have gone i j i am looking at difference combinations i and j so if either i or j 
so we will use indices zero to n so for i in becomes mn or j becomes n it means that correspond,so we will use in this 0 to n so if i becomes m or j becomes n it means that that corresponding 
with a procedure come clever that the key thing to dynamic programming is to be it to,the procedure become clearer but the key thing to dynamic programming is to be able 
n is zero because you go one pass the length of the and if we have not one pass a len,n is 0 because you gone past the length of v and if you are not gone past the length 
then equation form the inductive definition that we put goes in the earlier,an equation form the inductive definition that we purposely earlier 
n so here is for example for example this bisect and secret and so we have position zero to five and then we,so here we saw example for bisect and secret we have position 0 to 5 and then we have the 
to understand the inductive structure so you need to able to i take a problem identify how,to understand the inductive structure so you need to take a problem identify how the 
are this way so the arrows that indicating that and in order to solve this i need to solve,at this ways to the arrows are indicating that and in order solve this i need to solve 
says that the corner and the actually the right column and the bottom thing do not,which says that the corner and the actually the right column and the bottom thing do not 
so we can actually fill in those values are zero so that is given to us by definition,we can actually fill in those values as 0 because that is given to us by definition 
now we said earlier that we have found focusing on the length of the longest common subword,and now we said earlier that we are focusing on the length of the longest common subword 
we said that list are mutable objects,we said that lists are mutable objects 
this will be useful because data not we will find that with in python we can actually exam,this will be useful because later on we will find that within python we can actually examine 
in errors and take a to an alternative action if an error occurs and we can single what type of the,errors and take alternative action if an error occurs and we can signal what type of error 
we would normally or text set the function append to take two arguments the list and the value,we would normally expect the function append to take two arguments the list and the value 
and x is false an argument to the function append so we,and x is supposed to be an argument to the function append 
get what is called object oriented programming with in python,at what is called object oriented programming within python 
so we go back to our old example list one is one three five six and list two is,so we go back to our old example list1 is 1 3 5 6 and list2 is list1 
in the same way if i say that list one from slice to with the it becomes seven eight it,in the same way if i say that list1 from slice two to the end become 7 8 it changes 5 6 
all the other hand because i use plus what i have done is that created a new list or an,but on the other hand because i used plus what i have done is i have created a new list 
now safe one three seven eight,so both of them now say 1 3 7 8 
so we preserved the structure of the list in terms of the number of positions up the,so we preserved the structure of the list in terms of the number of positions 
this is not quite python allows you to both expand and strings,this is not required python allows you to both expand and shrink a slice 
the other thing we can do is shrink a list we can put a smaller thing,the other thing we can do is shrink a list we can put a smaller thing 
slice zero to two which will give us these two positions now have a slice of len,slice 0 to 2 which will give us these two positions so now you have a slice of length 
these two but we assign it a list of length one,two but we assign it a list of length one 
so this one three is replaced by just a single seven right,so this 1 3 is replaced by just the single 7 
using so you should be careful that you know what you are doing effect prime to directly,so you should be very careful that you know what you are doing if you are trying to directly 
we have date slices in list,updates slices in the list 
a very common things that we want to know what of list is whether a value,one of the very common things that we want to know about a list is whether a value exists 
now we can use this for instance to make a remove a safe operation before we move,now we can use this for instance to make our remove a safe operation before we invoke 
recall that removal moves only the first element so,also recall that remove removes only the first element 
in this,applying remove 
if i say list one into one three five six seven for example py six and i say list two is equal list one,so if i say list1 in to 1 3 5 6 for example and i say list2 is equal to list1 and then 
reverse the list and place l dot sort will sort a list in ascending order,reverse a list in place l dot sort will sort a list in ascending order 
python for every time,in python for every type 
so you do have to look up the documentation and if you think that there should be a function,so you do have to look up the documentation and if you think that there should be a function 
which does something natural very often there will be,that which does something natural very often there will be 
times i do this says,what happens if i do this 
have or do not be afraid to seen documentation you by looking up the documentation we,but above all do not be afraid to see in documentation only by looking up a documentation will you 
is names to not have types in python we do not have to announce a name names just pop up,names do not have types in python we do not have to announce the name names just pop 
as the code from the essence,up as the code progresses 
every time and name pops up python needs to know what value to its,so every time a name pops us python needs to know what value it is 
now append i to the list of factors which i will return,now to append i to the list of factors which i will return 
it so now list one is again one three seven six but it is two which was pointing to list one is no longer point,now list1 is again 1 3 7 6 but list2 which was pointing to list1 is no longer pointing 
this initialization is only need a to tell python when this first append happens that,this initialization is only needed to tell python when this first append happens that 
is a valid function to apply to this name without this you get an error so,a valid function to apply to this name without this you will get an error 
are contract the list but this is something to be done with care must make sure,or contract the list but this is something to be done with care you must make sure you 
and to go through all of them as also very going to just list out of this,and to go through all of them and it is also a very boring to just list out of a bunch 
inside a function we want to update a list then so long as we do not reassigned,if inside a function we want to update a function list then so long as we do not reassign it 
the function will not reflect outside the from,the function will not reflect outside the function 
inside the function this would not to,inside the function this would not do 
is a function which will take a list and add a value,append is a function which will take a list and add a value to it 
sort a new list in that sense,not a new list in that sense 
so append actually as a value in place both list one and list two point to the new list with,append actually adds a value in place both list1 and list2 point to be new list with 
now if i take the position two which is this position and replace it by the value seven then,now if i take the position 2 which is this position and replace it by the value 7 then 
the other hand if we are done l lie convention using the plus operator then,on the other hand if we had done it like i mentioned using the plus operator then we 
so the so append takes a single value,so append takes a single value 
we want to put six eight ten,we wanted to put 6 8 10 
right so we want to one three five and we want to expand this to have three more values,so we want to take 1 3 5 and we wanted to expand this to have three more values 
of course we can append each of these value one at,of course we can append each of these value one at a time 
now this is to add elements so list there is also a way to remove an element,now this is to add elements to a list there is also a way to remove an element from a 
the list,list 
object we have that list two also has same value one three seven six,object we have that list2 also has the same value [1 3 7 6] 
well in fact this will give us an error so you have to be careful to use remove only,well in fact this will give us an error so you have to be careful to use remove only 
now if i say list two dot to move say finally now there are two copies of five remember the first copy,now if i say list2 dot remove say 5 now there are two copies of 5 remember the first copy 
which is here the cleaning in a second pop it reads later so this will remove the,which is here in the beginning and second copy which is later so this will remove the 
rather than a list two the first once efficient go to six but the second copies that it if i say that,now if i look at list2 the first one skip at 4 to 6 but the second copy is still there 
now what happens where move it the third time now i get an error saying x is not in,now what happens if i have remove it a third time now i get an error saying x is not in 
an error or,an error 
there is no multiplication for pos is zero and so we can then write out,is a just matrix there is no multiplication so the cost is 0 we can then write out this 
entry i comma j then i need to choose a put k it and,entry i comma j then i need to choose a good k 
and in order to choose a good k i need so this i can express in many different place it,and in order to choose a good k i need so this i can express in many different ways 
have to say of k thing this entry i to i and then i want the entry i plus one than j so i have,i have to say pick this entry i to i and then i want the entry i plus 1 to j so i have 
we could have order n values any to compute for this any to compute,in general we could have order n values i need to compute for this i need to compute 
only thing that you need to a note is that we have to use some,only thing that you need to notice that we have used some 
so what we are doing is when we compute as we said one entry so supposing we are computing,so what we are doing is when we compute as we said one entry supposing we are computing 
longest common subword we assume that the maximum was zero to time we saw,longest common sub word we assume that the maximum was zero and every time we saw a 
are see is actually infinity now what is infinity well you can take infinity so that we can,r c is actually infinity now what is infinity well you can take infinity so that we can 
the total time machine will not be more than so if we take the product all,the total dimension will not be more than that so you can take the product of all 
is just a way to make sure that we go it go through this table diagonal by diagonal,else is just a way to make sure that we go it go through this table diagonal by diagonal 
saw with pairs in that row and column,all pairs in that row and column 
south it does not matter whether we first multiply a b and then multiply c or refers to but by a,out it does not matter whether we first multiply ab and then multiply c or we first multiply 
the point was each entry takes constant time so the a for to import the same this i,but the point was each entry takes constant time so the effort involved is the same as 
so we saw that and entry will take time proportional to its distance so the diagonal,right we saw that an entry will take time proportional to it is distance from the diagonal 
is done and in all the examples we saw before the pivot,example in all the examples we saw before the fibonacci 
six times three times two that the matter we were them to six then three first of three times two first,do 6 times 3 times 2 it does not matter whether you do 6 times 3 first or 3 times 2 first 
complexity of computing learns wise this thing case,complexity of computing the answer why is this the case 
a single entry so i get one into one hundred into one hundred steps i just collapse this row and,1 single entry so i get 1 into 100 into 1 in 100 steps i just collapse this row and 
this column into a single it as like computing one entry none matrix one,this column into a single entry that is like computing one entry in a matrix multiplication 
in which you do the associated steps can dramatically improve or worsen the amount of time use,in which you do the associative steps can dramatically improve or worsen the amount 
so in general we have a sequence m one to m and n each of them as some rows and columns,in general we have a sequence m 1 to m n and each of them has some rows and columns 
to it so we can add test two matrices at a time we only know how to multiply a times,would do it so we can at best do two matrices at a time we only know how to multiply a 
answer which is m times p so in the final entry we have to do mp we have to make empty entries in the final product,answer which is m times p in the final entry we have to make mp entries in the final product 
in which to do this definition so that we optimize the operations are,and which to do this calculation so that we optimize the operations involved 
it must reflects and must have this whole thing for a into c,group it must look like this and must have this whole thing collapsing to some m 1 prime 
thing is my the other worst case is i could have done m one two not worst but extreme k,whole thing is my the other worst cases i could have done m 1 2 not worst but extreme 
we know comma change to cause and to this we have to recursively add the induct,we know how much it is going to cost and to this we have to recursively add the inductive 
so that takes a order n time so the total work it is usually easy to compute as m times,so that takes us order n time with total work is usually easy to compute us m times 
how much time we take up to n to the right so,how much time it will take us to do m 2 prime 
that sub problems so we did the longest common subsequence problem we at two sub dot,1 sub problems so when we did the longest common sub sequence problem we had two sub 
of k we have no way of knowing which of these case better so again we try all of them,of k we have no way of knowing which of this case is better so again we try all of them 
is of k of the cost of multiplying m one to m k plus the cost of multiplying m k plus one to,of k of the cost of multiplying m 1 to m k plus the cost of multiplying m k plus 1 to 
result of inductively sorting the rest so this is a very attractive way of describing,result of inductively sorting the rest this is a very attractive way of describing the 
table here right so we have a table where in some order as and early matter from,table here right so we have a table where in some order it does not really matter for 
the base case in the function we will get back that fib of one is one so we store the,the base case in the function we will get back that fib of 1 is 1 so we store this 
is in the table this is the first value we are actually computed what is we did not assume,in the table this is the first value we have actually computed notice we did not assume 
one so we store that in the table we say for k equal to two fib of k is one now week a,1 so we store that in the table we say for k equal to 2 fib of k is 1 now we come 
back to fib of three and now we go down it asks is to compute fib of one again now although,back to fib of 3 and now we go down and it asks us to compute fib of 1 again now although 
so this does not take us any work because it is a base case we do not actually exploit,this does not take us any work because it is a base case we do not actually exploit 
there is and so we pick it up so we highlighted or use the fact that the,there is and so we pick it up we highlight in orange the fact that this 
this value is actually not recomputed but look up in the table so from one plus one we,value was actually not recomputed but looked up in the table so from 1 plus 1 we now 
now of fibonacci of three is two now we go back up the fibonacci of four init ask us to come to,have fibonacci of 3 is 2 now we go back up to fibonacci of 4 and it asks us to compute 
the second half or fits a sub problems then the fibonacci of two once again we find that the,the second half of its sub problems namely fibonacci of 2 once again we find that there 
so we end up so notice therefore that if the value we computed,so we enter that notice therefore that every value we computed 
now what fibonacci says is the first thing you do when you get a number is trying to,now what fibonacci says is the first thing you do when you get a number is try and look 
otherwise we go through the recursive computation so this is the usually computation which remain,otherwise we go through the recursive computation this is the usual computation which will make 
a recursive call and eventually come up to the new value which is the value for this predict,a recursive call and eventually come up with a new value which is the value for this particular 
a dictionary and not a list because the arguments to be any particular so we could,dictionary and not a list because the arguments could be any particular values they could 
so we basically for given the particular combination of arguments we look up whether that combination,we basically for given the particular combination of arguments we look up whether that combination 
of keys is there in the dictionary if so we look it up and return it otherwise we compute,of keys is there in the dictionary if so we look it up and return it otherwise we compute 
the new value for this combination store it and then it up so we have glossed of,a new value for this combination store it and then return it so we have glossed over 
the base case to the case we had that means there are always some values some,the base case to the case we have at hand that means there are always some values some 
base values for which no for the values three we computed these values are automatically,base values for which no further values need to be computed these values are automatically 
its right so there will always be a starting point and we can solve the sub problems directly,this right there will always be a starting point and we can solve the sub problems directly 
to follow the inductive structure we can directly say ok telling which are all,have to follow the inductive structure we can directly say ok tell me which are all 
so we can start at the bottom and then work ourselves up we can say look a few,dependencies so we can start at the bottom and then work ourselves up we can say fibonacci 
uneven going to it from five and not counting down from five we have just directly filling up the table,even going to it from 5 i am not coming down from 5 we are just directly filling up the 
in general when we have such inductive definitions what we do is we have some problems that,in general when we have such inductive definitions what we do is we have sub problems that we 
of three so we this compute we have three and four so we can compute a min one three,of 3 so we just compute it we have 3 and 4 so we can compute i mean 2 and three so 
ny can to ask me for the ten fibonacci number i can write it out i can say of zero,when i can you ask me for the tenth fibonacci number i can write it out i can say 0 0 
we have to solve in order to get to the answer we are trying to be so for instance,have to solve in order to get to the answer we are trying to reach so for instance 
up to learn and table by time by recursion to fill them up iteratively starting with the ones,up in the mem table by recursion to fill them up iteratively starting with the ones which 
to compute factorial of n one of the things we need to compute factorial of n minus one,to compute factorial of n one of the things we need to do is compute factorial of n minus 
takes an we just take the i value to be the sum of the i minus one i minus two values,each stage we just take the ith value to be the sum of the i minus 1 i minus 2 values 
which we have already computed because we are going and this particular order,which we have already computed because we are going in this particular order because 
we call a memo table says called memoization and we always look up the table before,we call a memo table this is called memoization and we always look up the table before we 
so we call factorial of n minus one a sub problem of factorial n,1 so we call factorial of n minus 1 as sub problem of factorial n 
smaller than n similarly for insertion sort in order to sort the full list we need,smaller than n similarly for insertion sort in order to sort the full list we need to 
to sort all the elements excluding the first one what is called the tail of the list and,sort all the elements excluding the first one what is called the tail of the list and 
in turn we need to sort its tail and so on so in general when we do insertion sort we will,in turn we need to sort its tail and so on in general when we do insertion sort we will 
the actual value of f for our given input y by combining this solutions is to be sub prompt,the actual value of f for our given input y by combining the solutions to these sub 
fibonacci numbers are zero one and then you add it so one plus one is one plus zero is one plus one is two three five and so on,fibonacci numbers are 0 1 and then you add so 1 plus 0 is 1 1 plus 1 is 2 3 5 and 
so you just keep adding the previous,so on so you just keep adding the previous two 
itself so if n is zero return zero of n is one if it on one other,n itself so if n is 0 return 0 if n is 1 we return 1 
on and might is to add these two and return this value so here is a clear case of an inductive definition,1 and n minus 2 add these two and return this value here is the clear case of an inductive 
we can complete the computation of fibonacci to we get value is one plus zero another words one,we can complete the computation of fibonacci 2 we get value is 1 plus 0 in other words 
now we are back to fibonacci of four and we have computed the left side of fibonacci of,now we are back to fibonacci of 4 and we have computed the left side of fibonacci of 
four so we make to the right side and now what happens is we end up having to,4 so we need to compute the right side and now what happens is we end up having to 
of four and fibonacci of three so we are done with four so now we want to do fibonacci of three so no to,4 and fibonacci of 3 so we are done with 4 now we want to do fibonacci of 3 notice 
that we have already computed fibonacci of three but this will blindly require us to,that we have already computed fibonacci of 3 but this will blindly require us to call 
down go all the way up and eventually fibonacci of three will of course give us the same ones,down go all the way up and eventually fibonacci of 3 will of course give us the same answer 
five is five,5 is 5 
so what we want to do is move away from this naive recursive implementation of an inductive definition,so what we want to do is move away from this naive recursive implementation of an inductive 
in and try to or two words never reevaluating a sub problem so this is easy to do,definition and try to work towards never reevaluating a sub problem this is easy to 
if we could only remember the sub problems that we solved before then all we have,do if we could only remember the sub problems that we have solved before then all we have 
for efficient then insertion sort of selection sort and we claim it also that it operates,more efficient than insertion sort or selection sort and we claimed also that it operates 
in a and b and move the smaller of the two to c so clearly seen closer one element we,in a and b and move the smaller of the two to c so clearly c grows by one element with 
continue with the old values from the recursive call star so this requires certain unknown,continue with the old values when the recursive call is done this requires a certain amount 
to extra work so recursive calls and returns turn out to,of extra work recursive calls and returns turn out to be 
this is only a minor comment but conceptually merge sort is the basic order n log n sort,is only a minor comment but conceptually merge sort is the basic order n log n sorting 
algorithm and it is very useful to know because it plays a role in many other things in directly,algorithm and it is very useful to know because it plays a role in many other things indirectly 
ordering,or directly  
of c is m plus n then what we do in each iteration we do,of c is m plus n what do we do in each iteration well we do 
a comparison and then we do an assignment and then we increment something to six so the,a comparison and then we do an assignment and then we increment some indices so this 
we can say that merge has a function takes time of the order of maximum of m and n and,we can say that merge as a function takes time of the order of maximum of m and n and 
n elements is two times the time taken for two list of n by two and this is a merge component,n elements is two times time taken for two list of n by 2 and this is the merge component 
we start with the base case if we have a list of size one then we have nothing to,we start with the base case if we have a list of size 1 then we have nothing to do 
so we write two times two is to square we write this for us to so it we will,this so we write two times 2 as 2 square and we write this 4 as two squared we will 
find that this is equal and writing it in this found to two to squared t n by two so,find that this is equivalent to writing it in this form 2 into 2 2 squared t n by 2 
so we expand two times t n by four that you give us another in by eight,so we expand two times t n by 4 and that will give us another n by 8 which you write 
so in order to analyze merge sort the first seen we need to do is to give as,in order to analyze merge sort the first thing we need to do is to give an analysis 
this has become one and so we test separate so we have two to the j which log n plus this j is,has become 1 so it has disappeared we have 2 to the j is 2 to the log n plus this j has 
three and two three then we end up to the list of the form one two three so this is how,say 1 3 and 2 3 then we end up with the list of the form 1 2 3 3 this is how merge 
so merge can be used to implement the s combinations combination operations and lists,so merge can be used to implement various combinations combination operations on this 
can we use to take the you cannot two lists and this car duplicates can use to,it can be used to take the union of two lists and discard duplicates it can be used to 
take the discussion up to this and finally as an x is size test that you understand,take the intersection of two lists and finally as an exercise to test that you understand 
cf you can use merge two lists difference the list,it and see if you can use merge to do list difference 
so merge sort is clearly so c or to insertion sort and selection sort because it is order n,now merge sort is clearly superior to insertion sort and selection sort because it is order 
of merge sort is that we have flows create a new array everytime we merge two lists,of merge sort is that we are forced to create a new array every time we merge two lists 
the other problem with merge sort is that it is inherently recursive so merge saw,the other problem with merge sort is that it is inherently recursive and so merge sort 
the jobs should get to the two teaching assistants in each one is stored to o,the job is distributed to the two teaching assistants so each one is told to go with 
we do is both are not empty so we want to take the smaller one of the head of a and,what we do is if both are not empty so we want to take the smaller one of the head of 
is to n so we compare the first element to be any and we move the smaller one it is,is remaining so we compare the first element of a and b and we move the smaller one into 
c and we keep repeating this until all the elements thing a and b have been fit,c and we keep repeating this until all the elements in a and b has been moved 
this is a python implementation of this merge function in general the to list need not,this is a python implementation of this merge function in general the two lists need not 
the same length so we are merging a of length m a and b of length n into an output,be the same length so we are merging a of length m and b of length n into an output 
are the papers sort them separately and come back and then the instructor has to put,halves the papers sort them separately and come back and then the instructor has to put 
moved so far to the output eventually everything in a everything in j will be must is more,moved so far to the output eventually everything in a and everything in b must be moved to 
cases are where one of the two list is empty either we have reached the end of eight saw,cases are where one of the two lists is empty either we have reached the end of a so i 
or the index into similarly if we have reached the end of p we append,b or the index in b similarly if we have reached the end of b 
the unsorted array or list into two parts and then you handle word to these two parts to,the unsorted array or list into two parts and then you hand over these two parts to 
in so these two things will definitely work just a checking the fact that we have,left in it these two things will definitely work just by checking the fact that we have 
now nine a list is exhausted then we have to do comparison so we come to the,now if neither list is exhausted then we have to do a comparison so we come to this 
which of these two goes to seen x so the smaller of the two if it comes in a we append i,which of these two goes into c next the smaller of the two if it comes in a we append that 
in the correct order from a and b into says,in the correct order from a and b into c 
so here is a file merge dot py in which we have exactly the same code as we had in the slide,so here is a file merge dot py in which we had exactly the same code as we had on the 
so this in this way to do this is to try and constructed two lists of a suppose we take a list,the simplest way to do this is to try and construct two lists suppose we take a list 
the code in a couple of places so we have two situations case one and case for where,the code in a couple of places so we have two situations case 1 and case 4 where we 
one so if we take the value from b so we combine one and four and say either it a seventy,ones where we take the value from b so we combine 1 and 4 and say either if a is empty 
i j could j plus one on the other hand either if a some b is empty,j equal to j plus 1 on the other hand either if b is empty or 
up a has a smaller value then you take the value from the end append bc x and right so let us,a has a smaller value then you take the value from a and append the index in that right 
out the values so the names at some brute it point now here since we are having an error,the values of the names at some appropriate point now here since we are having an error 
says is set we have not formally seen in this see it in the next week but it does into to,as i said we have not formally seen we will see it in the next week but it does the intuitive 
it is trying to check whether the i is bigger than b j a but this point unfortunately,it is trying to check whether a i is bigger than b j but at this point unfortunately 
now we are only checking if a i is three since i is not the we are going right and checking,now we are only checking if i is 3 since i is not 3 we are going at and checking the 
index and sometimes it is implicit and sometimes we have to be careful and this is one of the,index and sometimes it is implicit and sometimes we have to be careful and this is one of those 
is will go back to the version with four explicit cases,so we may as well go back to the version with four explicit cases 
so slices of our list so we will actually have merge sort we can input list and,or slices of our list so we will actually have merge sort within input list and the 
sort dot py we start with the function merge which we saw before with the for greatly split,sort dot py we start with the function merge which we saw before with a four way case split 
sorted in sequence,sorted in sequence 
under times larger one hundred thousand as opposed to a few thousand then insertion sort of selection sort,times larger 100000 as suppose to a few 1000 then insertion sort or selection sort another 
a small point keep in mind is notice that we did running to this recursion limit prompt,small point to keep in mind is notice that we did not run it to its recursion limit problem 
log recursive calls so one hundred thousand elements also requires to read log hundred thousand remember or,log n recursive calls so 100000 elements also requires only log 100000 remember a 
a problem with the recursion limit we do not have any pending recursions of that def,a problem with the recursion limit we do not have any pending recursions of that depth 
we will actually calculate y merge sort is order n knocked,we will actually calculate why merge sort is order n log n  
to up that it now sixty four is the smaller of the two at the head what is here these a situation,two at the end now 64 is the smaller of the two at the end notice we have reached the 
copy the first list as it is without having to compare anything because those are a,copy the first list as it is without having to compare anything because those are all 
the right hand side of a slice goes of the slice minus one,the right hand side of a slice goes up to the slice minus 1 
minus one we can just duplicate the index of the right hand side and the left,plus 1 minus 1 we can just duplicate the index of the right hand side and the left 
out sort anything except the list of length one or zero so we for the grid so now we,how to sort anything except a list of length 1 or 0 so we further break it up now we 
or ninety one so now at this level we have two lists of lengths,before 91 now at this level we have two lists of lengths 
so this is thirteen and then we pick twenty two then we get thirty three thirty two and then we pick fifty self for fit forty three then fifty seven,so this is 13 and then we will pick 22 then we pick 32 and then we pick 43 then 57 then 
it up down to the base case and then it we combine backwards using the merge,it up down till the base case and then you keep combining backwards using the merge 
which do not have any difference which with each other so here for instance sorting,which do not have any interference with each other so here for instance sorting the 
ask it to go to two separate rooms they do not need to communicate teacher,ask them to go to two separate rooms they do not need to communicate with each other 
into independent sub problems and then you have a efficient way to combine the sorts,into independent sub problems and then you have efficient way to combine the solved sub 
sub problems so that is its heap how efficiently you can combine the problems if it a,problems so that is the key there how efficiently you can combine the problems if you takes 
let us look a little more detail at the actual algorithmic as set of how we will to do this,let us look a little more in detail at the actual algorithmic aspect of how we are going 
to stick every key item so we have a i then we go directly to i plus k so implicitly,to skip every k item so we have i then we go directly to i plus k so implicitly if 
we must use this type conversion called list so in general we can use type names to convert,we must use this type conversion called list in general we can use type names to convert 
to do is we will get i plus n key for the largest answers i plus n k smaller than j,do is we will get i plus n k for the largest n such that i plus n k is smaller than j 
increment if case negative in steps of k such that you keep going as far as possible,decrement if k is negative in steps of k such that you keep going as far as possible 
happens is that if we start with the value which is smaller than the current value,happens is that if we start with the value which is smaller than the target value we 
it range j this is seen as the upper bound and the lower count is zero this is like s lie,write range j this is seen as the upper bound and the lower bound is 0 this is like a slice 
of backwards so just to see an example suppose we want to,or backwards just to see an example suppose we want to 
we go to three and if we were to go one more step you go to zero but since zero process one,go to 3 and if we were to go one more step you would go to 0 but since 0 crosses 1 in 
the red negative direction we would stop its treats if we would cross forward to zero,the negative direction we would stop at 3 itself we would not cross over to 0 
these where if we do not right the first argument of the slice if we write for instance l colon n,where if you do not write the first argument of the slice if we write for instance l colon 
two and python three python into the output of range is in fact the list so if you run,2 and python 3 in python 2 the output of range is in fact the list so if you run 
is not a list so range produces something which is a sequence of values which can,is not a list so range produces something which is a sequence of values which can be 
now it is possible to use range in generate a list using the function list case of the name a,now it is possible to use range to generate a list using the function list so name of 
the function is actually list so what would do for example is give the range as an argument,the function is actually list what we do for example is give the range as an argument 
a list this is an example of a type conversion we have to,list this is an example of a type conversion we 
is that python internally uses for types also as functions to convert one type to another,that python internally uses for types also as functions to convert one type to another 
is happens implicitly for instance as we will see when we want to display a value we use,this happens implicitly for instance as we will see when we want to display a value using 
or none when we print out something is x this str is implicitly use way of,or when we print out something is text so str is implicitly used very often sometimes 
instance in the string consists only of digits then we should get a value corresponding,instance if the string consists only of digits then we should get a value corresponding to 
conversion is possible it will do it if we does and it returns an error we use,conversion is possible it will do it if it does not it returns an error we will see 
in python the recover for an error out which check what error it is and proceed according to,within python to recover from an error or to check what error it is and proceed accordingly 
a for the last lecture this tree we look at some useful things which are allowed will crop up to n,for the last lecture this week we look at some useful things which will crop up and 
if the user does not present a valid value which of telling them white we just keep,if the user does not present a valid value instead of telling them why we just keep saying 
enter a number or min and we have seen this any number of time so if you go to some use,enter a number i mean we have seen this any number of times right you go to some user 
a contracts the list and shifts everything from position five on what so the left by one,contracts the list and shifts everything from position 5 on wards to the left by 5 so let 
handling right so supposing we want to assign a vale to a name x only if x is undefined then,handling supposing we want to assign a vale to a name x only if x is undefined then we 
or not so far but it is not a good idea to just leave it and defined and then use exception,or not so far it is not a good idea to just leave it undefined and then use exception 
is a valid value we can initialize it to none later on we can check if it is still none,a valid value we can initialize it to none and later on we can check if it is still none 
so initially we say x is equal to none and finally we go right l say oh if x is not none,so initially we say x is equal to none and finally we go ahead and say if x is not none 
so we are using the is a not equal to so there is exactly one value none in python in the space again so all,we are using is not equal to so there is exactly one value none in python in the space 
with the user of provided a string which is not a valid integer in which case will,if the user has provided a string which is not a valid integer in which case we will 
the list or a dictionary if you would not normally want to just and define a name which is holding a,a list or a dictionary you would not normally want to just undefine name which is holding 
by saying that the number of nodes at level a i is two to the i so initially we have one,by saying that the number of nodes at level i is 2 to the i initially we have 1 node 
the other operation we need to implemented a heap is delete max now one thing about,the other operation we need to implement in a heap is delete max now one thing about 
then that tree must be or two so we know where the root is now the question,value in the entire tree must be at the root so we know where the root is now the question 
move this value then we have to put some value they are on the other hand the now,remove this value then we have to put some value there on the other hand the number 
the top the there is going to be some problem with respect to itã•s children so in,the top obviously there is going to be some problem with respect to itã£â€¢s children so 
smaller than twenty four,smaller than 24 
at this point eleven is bigger than ten so we sort out so just,children at this point 11 is bigger than 10 so we stop 
lean there are no properties to we sort us our satisfy to move so we stop,leaf there are no properties to be satisfied anymore so we stop 
very attractive feature of key is that we can implement this tree directly in a list,one very attractive feature of heaps is that we can implement this tree directly in a list 
for in an array so we have an n node heap we can represented as a list r and,or in an array so we have an n node heap we can represent it as a list or an array 
as we said we filled or this heap left to right top to bottom right in the same way,as we said we filled up this heap left to right top to bottom right in the same way 
we will call insert and insert just adds new job the list any job when it is,we will call insert and insert just adds a new job to the list and each job when it is 
add it comes with its own priority base,added comes with it is own priority 
building the heap so as we are going are the number of steps that we need to property,we are building the heap so as we are going up the number of steps that we need to propagate 
the other hand a number of nodes for weeks this happens is smaller,other hand the number of nodes for which this happens is smaller 
a four nodes we have to do one level of shifting perhaps repair the heap property in then we,for 4 nodes we have to do one level of shifting perhaps to repair the heap property then we 
we have n nodes for so the number of nodes for which this is x y as we heap,have only two nodes for this the number of nodes for which this is required is shrinking 
our job so just as a list now if it is an unsorted list when we add something to the queue,jobs just as a list now if it is an unsorted list when we add something to the queue we 
for heap now the question is better we keep these values where remember that a heap is a knight,now the question is where do we keep these values well remember that a heap is an array 
max will remove the element in the top of that a root but it will,delete max will remove the element at the top because that is the root but it will 
also create a vacancy here this is the value that will go to the top to the last,also create a vacancy here this is the value that will go to the top this is the last 
will now go to the end of the heap but the next time it process the heap there we will,will now go to the end of the heap but the next time we process the heap there will be 
is fixed and so on so one by one the maximum value second maximum value and,elements fixed and so on so one by one the maximum value second maximum value and so 
will get to the same list are arranged or storing heap and in range,on will get into the same list or array in which we are storing the heap and eventually 
summarize said heap six are at revisit implementation a priority queues so in which both insert,to summarize heaps are a tree based implementation of priority queues in which both insert and 
however to do a delete max we have to scan through the list and search for the maximum element,to do a delete max we have to scan through the list and search for the maximum element 
now in this case we are will get max things we can also do word you will construction where,now in this case we were looking at max heaps we can also do a dual construction where we 
when we insert something at the bottom we have to move it up so the inserted,when we insert something at the bottom we have to move it up right so the insert and 
as we have seen in an unsorted list if it will take us order n time to find the max,and as we have seen in an unsorted list it will take us order n time to find the maximum 
it node the node above it and we refer to the children and the left check the right child,the node above it and we refer to the children as the left child and the right child 
of our goal is to maintain a priority queue as a special kind of a binary tree which we,so our goal is to maintain a priority queue as a special kind of binary tree which we 
n log n we will are still both insert and delete max in order log n time,log n we will achieve both insert and delete max in order log n time 
will go from n squared two n log n and another nice teacher about a heap is that we do not have to,go from n squared to n log n and another nice feature about a heap is that we do not have 
that which are the values which are stored in the tree remember that leaves a nodes in a final,which are the values which are stored in the tree remember that leaves nodes in a binary 
entry may have zero children one children or two children so we could have in general a very,tree may have 0 children 1 children or 2 children so we could have in general a very 
tree in which we to each level from top to bottom left to right,tree in which we fill each level from top to bottom left to right 
the other property did the heap the first property structural tells us tells us,the other property with the heap the first property is structural it just tells us how 
of those which have values and the empty nodes are indicated with open circles that,are those which have values and the empty nodes are indicated with open circles at the 
sort it is two children so at every node if we look at the value and we look at the value and,of its 2 children so at every node if you look at the value and we look at the value 
are priorities so that can always pull out we quickly the one with the highest priority into still,priorities so that it can always pull out very quickly the one with the highest priority 
i so we have the value property the max heap property along with the structural property,5 so we have the value property  the max heap property along with the structural property 
seven so once again this is not being filled correctly left to right top to bottom,child of 7 so once again this has not been filled correctly left to right top to bottom 
number the heap nodes are constructed top to bottom left to right so if we want to insert,remember that heap nodes are constructed top to bottom left to right if we want to insert 
are is bigger than its parent n so although this is,12 is bigger than its parent 10 although this is now structurally correct 
now structurally can at it does not have the right value distribution so we have to restore the heap property,it does not have the right value distribution so we have to restore the heap property in 
is like a queue but if you are which items up priority based on some other characters,this is like a queue but a queue in which items have priority based on some other characteristic 
and then we start looking at violations with respect to its parent so we note is that well end,and then we start looking at violations with respect to it is parent we notice that 12 
a smaller than twenty four so we stop,is smaller than 24 so we stop 
we move thirteen to where twenty two up to twenty two and we push everything from seventy eight,we move 13 to where 22 is or after 22 and we push everything from 78 onwards to the 
the right but actually a clever a strategy is to say that to be thirteen the score the or,right but actually a cleverer strategy is to say that 13 must go here 
instead we can just take this thirteen the last element the yellow zone and replace,but instead we can just take this 13 in the last element to the yellow zone and replace 
here is implementation in python,here is an implementation in python 
so yellow is l plus one and now we let green to seen and every time we see an element,so yellow is l plus 1 and now we let green proceed and every time you see an element 
it to thirteen and then we move the yellow pointer otherwise if we,this is what we did to 13 and then we move the yellow pointer as well otherwise if we 
see a value which is strictly bigger we move and the green pointer which is implicitly,see a value which is strictly bigger we move only the green pointer which is implicitly 
a so if we want to sort something and see the that we have to assign it empty,if you want to sort something and see the effect we have to assign it a name and then 
instance take the range of values from a file hundred using two and now if we say quicksortl,let us for instance take a range of values from say 500 down to 0 then if we say quicksort(l) 
insertion sort we say one thousand right and then we write quicksort this you get this recursion that because,if we say 1000 and then we try to quicksort this we will get this recursion depth because 
to the says not we set the recursion limit something so to be large say that the,module and set the recursion limit to something superbly large say 10000 maybe 100000 and 
you were to for instance sort something of size say seven thousand five and then it takes the visible amount of,were to for instance sort something of size say 7500 then it takes a visible amount of 
because we are not using the median but the first value square,we are not using the median but the first value to speak 
we will see that in the next lecture is to y quicksort is actually not to us,we will see that in the next lecture as to why quicksort is actually not a worst case 
if the list,of the list 
so we do not need to merge,so we do not need to merge 
the recurrence the same one we get another order of an,the recurrence its the same one we get another order n log n algorithm 
that we said earlier that one of the benefits of sorting the list is that we,remember that we said earlier that one of the benefits of sorting a list is that we 
now here we are asking to the median before sort v needs to sort so it is kind,now here we are asking for the median before sorting but our aim is to sort it is kind 
if we are requiring the output of the sorted to be the input this sort so the,if we are requiring the output of the sorting to be the input to the sorting 
of looking for the median which us pick up some value in the list a and you,instead of looking for the median we just pick up some value in the list a and use 
that as what is called a pivot element,that as what is called a pivot element 
we split tree with respect to this pivot so that all the smaller elements are to the left and,we split a with respect to this pivot so that all the smaller elements are to the left and 
we partition a into the lower part and the upper part with respect to this pivot,we partition a into the lower part and the upper part with respect to this pivot element 
to because we have pick up the first element in the array to pivot so,two because we have picked up the first element in the array to pivot 
we recursively sort to functions,we recursively sort two partitions 
the extra space required at merge sort is actually required in order to implement,the extra space required by merge sort is actually required in order to implement the 
sil,ones are bigger 
merge function and y to we need to merge,merge function and why do we need to merge 
this is the rearrange extend and now we recursively sort yellow bits the green gets as to,this is the rearranging step and now we recursively sort the yellow bits and the green bits then 
things are smaller than forty three and all the green things a bigger than forty three no for than which in list one,things are smaller than 43 and all the green things are bigger than 43 no further merging 
and we want to do a scan of the remaining elements n divide them into two groups go smaller,to do a scan of the remaining elements and divide them into two groups those smaller 
is elements are and,elements are unknown 
so what we are trying to do is that trying to move from left to right and classify or,what we are trying to do is we are trying to move from left to right and classify all 
it strictly to it to the right of the green pointer we have to,element strictly greater than 43 and to the right of the green pointer we have those 
is which are yet to be scan so initial,which are yet to be scanned 
list then it takes a long time so we could actually check that for instance,list then it takes a long time so we could actually check that for instance 
can validates that claim that quicksort on an and which is last in so the when you give it these the,validates our claim that quicksort on an average is fast it is only when you give it these 
so very often sorting happens in c just on multiple at it its for example you might,so very often this sorting happens in stages on multiple attributes for example you might 
have a list of students were listed in alphabetical order to list,have a list of students who are listed in alphabetical order in the roll list after 
is disturbing the order of elements which already there will be unsorted its,is disturbing the order of elements which were already there in the unsorted list so 
we argued earlier to disturbing to sort it does not matter because we need to sort,we argued earlier that disturbing this order does not matter because any way we are going 
i these elements one particular order not for the current at two four,these elements were in particular order not for the current attribute but for the different 
that you and we move them around then we are destroying few is not sorted,attribute and we move them around then we are destroying the original sorted order 
of go backwards when we find some in which is equal to the current value we stop the section,go backwards and we find something which is equal to the current value we stop the insertion 
the array you partitioning into the new an upper parts queues which are smaller than the pivot,in the array you partition a into the lower and upper parts those which are smaller than 
sort in selection sort so t n to be one plus two up to n and this summation list is,sort and selection sort so t n would be 1 plus 2 up to n and this summation is just 
which are bigger than that you rearrange the array so that,the pivot and those which are bigger than the pivot you rearrange the array so that 
n values this into rely three and we can compute how much time quicksort takes an each of the,n values is equally likely and we can compute how much time quicksort takes in each of these 
it turns out that in a precise mathematical sense quicksort actually works in order to,it turns out that in a precise mathematical sense quicksort actually works in order n 
choose the first element as the pivot in our at and so in order to construct,choose the first element as the pivot in our algorithm and so in order to construct the 
and this,partitions 
say that each time we call quicksort we randomly choose a value in the range of elements,that each time we call quicksort we randomly choose a value within the range of elements 
pick that is the two then it turns out that we can be this order n squared,and pick that as the pivot then it turns out that we can beat this order n squared 
like that spreadsheet when we have a but in which says sort this column then more often,like a spread sheet where we have a button which says sort this column then more often 
in not the internal algorithm that is implemented is actually quicksort we saw that,they are not the internal algorithm that is implemented is actually quicksort we saw that 
python has a function ten dot sort which allows us to sort a list we to so you might asked to,python has a function l dot sort which allows us to sort a list built in you might ask 
example what sort this sorting algorithm python using very often it will be quicksort,for example what sort is sorting algorithm is python using very often it will be quicksort 
sil here we have for as before python implementation quicksort in which we have just,here we have as before our python implementation of quick sort in which we have just repeated 
to generate random its and one of the things that this like we have as is this,to generate random numbers and one of the things that this library has is this function 
sort them the input randomize so you can do this you can write five,quicksort and then we import randomize so you can do this you can write python functions 
an initial of at the version the list with the list colours the large,finish off that recursion limit process because we know this is gonna kill us so set a large 
worst case input except nodes in ascending or descending order and estimate,worst case input expect now it is an ascending order so both descending order and ascending 
by change the index from k to k minus one and then insert the current value into this is,but change the index from k to k minus 1 and then insert the current value into this sequence 
we say l is in range four five and it values say sil in descending order then if the insertion apply insertion,if we say l is a range of 500 values say in descending order then if we apply insertion 
for the maximum recursion ten so what happens when we make a recursive call is that,called the maximum recursion depth so what happens when we make a recursive call is that 
well the so let us try and see what this limit there,well first of all let us try and see what this limit is 
its so how do we define this inductively well we say that m times one is just m itself and,so how do we define this inductively well we say that m times 1 is just m itself and 
one to it turns out that we can sort seven fifty a it will turn out that for instance we can sort,it turns out that we can sort 750 now it will turn out that for instance we can sort 
of nested recursions which is less than one thousand if you want to change it you can by setting,nested recursions which is less than 1000 if you want to change it you can by setting 
so we could equivalently write this if you want to beast symmetric with the previous case as m times n is m plus m time,write this if you want to be symmetric with the previous case as m times n is m plus m 
for the inputs we are giving so that you can set this bound explicit,on the inputs you are giving so that you can set this bound explicitly 
recursive computation can also do on forever so the way that python stops this and four so,recursive computation can also go on forever the way that python stops this and forces 
in def it will refuse to execute the for,depth it will refuse to execute the code 
we need n minus one steps in the worst case to insert the last position into the sort,we need n minus 1 steps in the worst case to insert the last position into the sorted 
we get t of n minus k is equal to t of one so in other words when k becomes n after n steps,we get t of n minus k is equal to t of 1 in other words when k becomes n after n steps 
this is order n squared,this is order n squared 
of that is the fibonacci c so if we have seen the fibonacci câ€™s,of that is the fibonacci series if you have seen the fibonacci series the 
is equal to the second value is equal to one and after the second value fibonacci of n,is equal to the second value is equal to 1 and after the second value fibonacci of n 
is fibonacci of n minus one plus fibonacci of n minus two right so in general a recursive or inductive definition,is fibonacci of n minus 1 plus fibonacci of n minus 2 in general a recursive or inductive 
this is very clearly what we said before is as you of a to lose one another,this is very clearly what we said before it says zero factorial is 1 and otherwise 
before directly translated this recursive computation we can say the same for multiplication,before directly translated as recursive computation we can say the same for multiplication you 
say we want to multiply n by n if n is one we return n otherwise we add n to,can say if you want to multiply m by n if n is 1 we return m otherwise we add m to 
is that we do not have to spend much time undoing the this function is correct because,is that we do not have to spend much time arguing that this function is correct because 
list by adding one element at a time so we can think of decomposing a list reverse the,list by adding one element at a time so we can think of decomposing a list reversing 
say we had them to the left so we at the last element in b at the second last element,say we add them to the left we add the last element and we add the second last element 
and so on but conversely we can say that given a list,and so on but conversely we can say that given a list 
can decompose it by taking see the first element and looking at that first element,we can decompose it by taking say the first element and looking at that first element 
and so we will have a base case where the function is defined either for the end,thing so we will have a base case where the function is a defined either for the empty 
the list of for the simple list of size one and n the inductive step f of l will be defined,list or for the simple list of size 1 and in the inductive step f of l will be defined 
because this exactly how to define length inductive,because this is exactly how you define length inductively 
sil here is another function which says something similar x if instead of computing the length,now here is another function which does something similar except instead of computing the length 
us to add if i have an empty list then the sum will be zero because i have nothing to put,to add if i have an empty list then the sum will be 0 because i have nothing to put 
position and then it so we should be minus one so we take the value at the last position,position and then this should be minus 1 so we take the value at the last position 
of sorting the sequence up to but excluding the last position but the way we,result of sorting the sequence up to but excluding the last position but the way we 
it by multiplying by the value n we can also do other functions that you,by multiplying by the value n so we can also do this for other functions you may 
so if it is zero then an empty list if i a zero to one then i have a list of one position,if it is 0 then i have an empty list if i have 0 to 1 then i have a list of one position 
so this completes inorder traversal of the left subtree of i,so this completes inorder traversal of the left subtree of 5 
a search tree is to be able to do something like binary search and this is with and,a search tree is to be able to do something like binary search and this is with dynamic 
have insert and delete is operations button one main fundamental operation,so we will also have insert and delete as operations but the main fundamental operation 
i can binary search we start at the root,like in binary search we start at the root 
that so we always have self is the first seventeen to a function,we always have the self as the first parameter to our function 
if it is,if it is 
so if i have to go from the left most path in if i can to any further then i find it,so if i have to go from the left most path and if i cannot go any further then i find 
we will always apply this function only when tree nonempty sub,so we will always apply this function only when tree is non empty 
they cannot go further left then and found,if i cannot go further left then i found it 
this case if i reach one since i cannot go for the left one is the minimum value otherwise,in this case if i reach one since i cannot go further one is the minimum value otherwise 
no further right path from nine must be the maximum value this tree,no further right path from 9 9 must be the maximum value in this tree 
its with the tree,from the tree 
first function that we look for is insert so how do we insert an element in the tree,the first function that we look for is insert how do we insert an element in the tree well 
not all values are bigger than the current node value are to the right,all values that are bigger than the current node value are to the right 
an twenty eight and we find that we have exhausted this part and there is no possible twenty one in this,28 and we find that we have exhausted this path and there is no possible 21 in this tree 
of twenty eight so we insert the,so we insert it there 
and look for sixty five sixty,similarly you can start and look for 65 
here is an example of a binary search tree so you can check for instance that to the left,here is an example of a binary search tree you can check for instance that to the left 
write as though it,or on the right as appropriate 
so if we find the we must illegal,if we find v we must delete it 
right so supposing we first delete sixty five then we first search for sixty five we find it since it is a leaf,so supposing we first delete 65 then we first search for 65 we find it since it is a leaf 
in the maximum value to the left so we,the maximum value from the left 
what we the print it so we need to remove a,so we need to remove this 28 
the bigger swapped out remove the twenty eight and promote that twenty one,so we can just walked out remove the 28 and promote the 21 
it has no left child but nine is in the right subtree of eight,it has no left child but 9 is in the right subtree of 8 
if we just delete it and we make this node in the if on the other hand it has only one,leaf we just delete it and we make this node empty if on the other hand it has only one 
k if so if you actually in this case the left is empty then we just promote the right then and if it is,so actually in this case if the left is empty then we just promote the right and if it is 
three these are one,three fields are none 
just take basically this node and copy these values one by one or,so we just take basically this node and copy these values one by one here 
have two values we do each node put initially left child and a right child,have two values below each node potentially a left child and a right child 
of them is,are organized 
each with and then we have is empty n is the if we check whether the value is none,empty children then we have isempty and iseleaf we check whether the current value is none 
so each node now consist of three exits the value being stored the left child and the right,so each node now consist of three items the value being stored the left child and the 
move the leaf and make it empty fit this the left child is empty then we copy the right,remove the leaf and make it empty if it is the left child is empty then we copy the right 
we search for a value but binary search can be used if we can sort data once and for or,search for a value but binary search can be used if we can sort data once and for all 
the str function is this place the queen or others,and the str function just displays the inorder traversal 
the how to understand the fill in some order sil,so i am just trying to put it in some random order 
work so i can now insert a more values so if,so 1 2 3 4 i can now insert more values 
eight read three sil then i find that i want to four,3 then i find that i have 1 2 4 
so the have no children so,so they have no children 
are points to nine and the node with nine again has to none pointers because it is,pointer points to 9 and the node with nine again has two none pointers because it is 
this the empty tree will be a single empty node and l leaf node that is not none,with this the empty tree will be a single empty node and a leaf node that is not none 
one will have a value and both its children will be empty node,will have a value and both it is children will be empty nodes 
option works is follows right so we first set up the value to be date val,the init function works as follows right we first setup the value to be initval which 
to do is none so,point to this none none 
depending on whether a value is none or not none we end up either it tree three,so depending on that the init values none or not none we end up either a tree with three 
nodes two to done denotes zero or a single empty node denoting the empty,nodes with two dummy nodes below or a single empty node denoting the empty tree 
play this and then it will explore the right,display this and then it will explore the right 
so if we execute this step by step so five if we reach it says first do an inorder traversal,so if we execute this step by step 5 if we reach it says first do an inorder traversal 
we have to do an inorder traversal so we go to,so again we have to do a inorder traversal 
its left and now when we have one an inorder traversal of one consists,so we go it is left and now when we have one and inorder traversal of one consists 
is taking from zero to the length of l minus one,is varying from 0 to the length of l minus 1 
let us see how much time this takes,let us see how much time this takes 
expressions like this which have different terms like n square and to it turns out,expressions like this which have different terms like n n square n cube it turns out 
we said that an score sorting algorithm like selection sort which takes order n square will not,we said that for sorting algorithm like selection sort which takes order n square will not 
so let us start the python interpreter,let us start the python interpreter 
now in general we can take a longer list,now in general we can take a longer list 
so for sil so if i look at l its five hundred down to one,if i look at l it is 500 down to 1 
see there is an appreciable catch,see there is an appreciable gap 
and now if i do it for say thousand then this likely long so if,now if i do it for say 2000 then there is slightly longer gap 
star mark is below and so on,mark is below and so on 
is of the top than the lowest mark will be at the board,mark is on the top then the lowest mark will be at the bottom 
how do we do this well we just keep looking at each paper in turn each time we find a,how do we do this where we just keep looking at each paper in turn each time we find a 
now we have two papers stacked up in order as we keep doing this we will build up,now we have two papers stacked up in order as we keep doing this we will build up the 
a stack from bottom to top which has the lowest mark of the bottom and the highest mark,stack from bottom to top which has the lowest mark at the bottom and the highest mark on 
the top,the top 
then proceeding in this way at the next step we pick up fifty five and then sixty four and then seventeen,and then proceeding in this way at the next step we will pick up 55 and then 64 and then 
for instance the median value median value in a set is the value says that after,for instance the median value  the median value in a set is a value such that half the 
in this way by doing six scanned zone our list of six elements we have it up a new sequence,in this way by doing six scans on our list of six elements we have build up a new sequence 
this particular strategy which is very natural intuitive as a name is called selection,this particular strategy which is very natural and intuitive has a name is called selection 
the algorithm that we executed it just now we need to build up a second list of a second,in the algorithm that we executed just now we needed to build up a second list or a second 
move it to the beginning where it is supposed to be and exchange it with what is at the to its,to the beginning where it is supposed to be and exchange it with what is at the beginning 
now we no longer have to worry about the thing to do with twenty one we only need to look at this,now we no longer have to worry about anything to do with 21 we only need to look at this 
slices you want to call it that starting from thirty two,slice if you want to call it that starting from 32 
so we do this and we find the second smallest element,we do this and we find the second smallest element 
having finish this scan we would say fifty five should move to the third position,so having finished this scan we would say 55 should move to the third position and 89 
we can also do things like building frequency tables a checking for duplicates essentially one,we can also do things like building frequency tables or checking for duplicates essentially 
this way we just keep going on,this way we just keep going on 
and we have a sorted sequence using selection sort where instead of making a second sequence,and we have a sorted sequence using selection sort where instead of making a second sequence 
we have just systematically move the smallest element we have found to the start with this,we have just systematically moved the smallest element we have found to the start with the 
segment yourself section that we are looking at right,segment or section that we are looking at right now 
we will scan the sequence from one onwards then we will scan the sequence one two on word,then we will scan the sequence from one onwards then we will scan the sequence on two onwards 
to be the,the beginning 
zero and then it goes to one two up to the length of l minus one,0 and then it goes to 1 2 up to the length of l minus 1 
we started is now we could take another square for example,where we started from now we could pick another square for example 
we take the square of here and if we explore that it will again internal the,we could pick this square over here and if we explore that it will again in turn produce 
if neighbors and some of these neighbors overlapped the person indicate by,8 neighbors and some of these neighbors overlap the yellow neighbors i indicate it by joint 
process of marking the squares sometimes we mark a square twice is and we have,process of marking these squares sometimes we mark the square twice and we have to have 
then the squares that you can reach from x two will include squares an x one so how do we n show,then the squares that can reach from x 2 will include squares in x 1 so how do we ensure 
editor this question is how do we know when to stop,and related to this question is how do we know when to stop 
we have fruitlessly going i get and n are going to reach its so how,are fruitlessly going ahead and we are never going to reach the target square so how 
moved so we print the name colours we just get the list black red entry as,removed so if we print the name colours we just get the list black red and green 
the head of the queue and we look at all the squares reachable in one sets,the head of the queue and we look at all the squares reachable at one step 
me x in it by some of which are already marked some of which are marked just now,from a x and a y some of which were already marked some of which are marked just now 
what i can reach from there so this guarantees that a square which has been reached once,what i can reach from there so this guarantees that a square which has been reached once 
here is some python code for this so we are going to explore from s x s y t,here is some python pseudo code for this we are going to explore from s x s y to t 
be zero remember this list comprehension notation so it says zero for i in range n gives us a list,be 0 remember this list comprehension notation it says 0 for i in range n gives us a list 
of m blocks each block having n symbols so this says that initial nothing is not,of m blocks and each block having n zeros this says that initially nothing is marked 
node and the queue a so long as the queue is not empty we pop one element from,node from the queue now so long the queue is not empty we pop one element from the 
at some point is grows is s stop so the any i will return whether,at some point this process has to stop at the end i will return whether i will return 
so we say colours equal to set with the with no arguments like lists and other data structures we can,so we say colours equal to set with no arguments like lists and other data structures we can 
our first step is to remove this from the queue and explore its neighbors,so our first step is to remove this from the queue and explore its neighbors now 
test nine dish it using the so if in the previous its lists set colours which had red black and,test membership using in so if in the previous lists set colours which had red black and 
this time so we will just row it like this so we say that might queue cancels,it is more annoying so you just grow it like this so we say that my queue consists 
is nothing and it also has a new keeping here which is one zero continue,original thing and it also has a new thing here which is 1 0 so continuing like this 
is to zero but one of them is zero so i get a new may be zero then i continue,is 2 0 but one of them is 0 0 so i get a new neighbor 0 0 here and then i continue 
k now when i move from zero to two which is this one k i find that both its neighbors x float so n,now when i remove 0 2 which is this one i find that both these neighbors i explored 
had nothing i continue i to one again and find both is the papers x for into nothing,so i add nothing i continue with 2 1 again i find both its neighbors explored and do 
target is not reachable from to so,target is not reachable from the source node 
summarize a data structures are ways of organizing information that allow efficient processing,to summarize data structures are ways of organizing information that allow efficient processing 
sets either we also saw that we can take sequences and use then to structure trace so a stack,sets rather we also saw that we can take sequences and use them in two structured ways so stack 
saw that if we give no arguments to set you get an empty set but if we give a list,we saw that if we give no arguments to set you get an empty set but if we give a list 
is this one three to one for with duplicates and assign it to the name numbers then because,such as this 1 3 2 1 4 with duplicates and assign it to the name numbers then because 
it is a set the duplicate ones will be removed and we get a list of we get a set,its a set the duplicate ones will be removed and we will get a list of we will get a set 
will not be the order in which you provided it says that you must like a dictionary set,not be the order in which you provided it this is very much like a dictionary sets 
letters from the set so if we give this string one our none to the set function then we,letters from this set so if we give this string banana to the set function then we 
so as you expect sets support basic operations like the counter part it takes,so as you would expect sets support basic operations like their counterpart in mathematics 
the numbers to be the set up a prime numbers from one to it we two and eleven using,the prime numbers to be the set of all prime numbers from 1 and 11 between 2 and 11 using 
that are these the set function as we saw before so if we write just vertical bar then we can get,these set function as we saw before if we write this vertical bar then we can get the 
the stack so a stack is a last in first out list so we can only remove from a stack the element,a stack a stack is a last in first out list so we can only remove from a stack the element 
if we are because as we add queens and remove them what we need to do effectively stuff,behavior because as we add queens and remove them what we need to do effectively is to 
us so add q will add x to the tree or of the queue and remove queue will remove,you get served so add q will add x to the rear of the queue and remove q will remove 
this ugly but if we have gone through the documentation you find it,but if you have gone through the documentation you will find it 
in other words push an x to the beginning so if i have a queue of this pop and which has some,in other words push an x to the beginning if i have a queue at this form which has some 
then use pop just remove the last element list so queues than stacks can both the right easy,then use the pop to just remove the last element of the list queues and stacks can both be 
at position s x comma s y in this case the knight is denoted by this writes,at a position s x comma s y in this case the knight is denoted by this red symbol 
remaining string and treated two plus t again let us see how this works it suppose,remaining string and keep it with us so again let us see how this works 
by commas notice that is a string now if i say csv the line dot split using comma as separator,by commas notice it is a string now if i say csv line dot split using comma as a separator 
you want to that have to convert it using inter so these are still strings so it just,you want you then have to convert them using int or these are still strings so it just 
us so we will see all these in this lecture it,so we will see all this in this lecture 
to do it ones then i get the first six then seven it does not get split because,to do it once then i get the first 6 but then 7 and 8 does not get split because it 
really splits ones right now if i change this to something more finds,only splits once now if i change this to something more fancy 
a comma and then use that to join the columns so this is a bit confusing so joining it is a,comma and then use that to join the columns now this is a bit confusing so join is a 
function which are associated with a string in this case the string and concerned is a comma,function which is associated with a string in this case a string in concerned is a comma 
so it says more or less as saying comma dot join columns which is use comma to join,so it says more or less you are saying comma dot join columns which is use comma to join 
into the i from and then saying i from dot join and directly use the string itself,to the hyphens and then saying hyphens dot join i directly use this string itself just 
does want to illustrate that you can directly use the set the joining string itself as a constant string,want to illustrate that you can directly use this joining string itself as a constant string 
convert the first letter to upper case and keep the rest is lower case you say,convert the first letter to upper case and keep the rest as lower case if you say s 
the other fancy things like s dot title so title will at capitalize each word,there are other fancy things like s dot title so title will capitalize each word this 
the other thing that you can do with strings is to resize them took fit what you want so,the other thing that you can do with strings is to resize them to fit what you want so 
which is of length n and with s centered int now by centering what we mean is that,which is of length n with s centered in it now by centering what we mean is that on either 
of the other types of functions which you fine associated strings are but i,some of the other types of functions which we find associated to strings are to check 
so that is what s dot is al first it is it and alphabetic string if it is true,z so that is what s dot is alpha says is it an alphabetic string if it is true it 
we will if we need them as we go along we will use them and explain that,we will if we need them as we go along we will use them and explain them 
next tripling what is a part of pythons utility as a blue language for transforming things,an extremely important part of pythons utility as a glue language for transforming things 
string processing functions that make it easier to modify these contain,string processing functions that make it easier to modify this content 
s dot find pattern will return the first position and s which pattern occurs and,s s dot find pattern will return the first position in s which pattern occurs and if 
to do something with these you can use the built in string functions which a quite a file,and to do something with this you can use built in string functions which are quite 
of error in this case a value error so again let us just see how these things actually,of error in this case a value error so again let us just see how these things actually 
we have a string here s which contains the word brown fox grey dog brown fox,so we have a string here s which contains the word brown fox grey dog brown fox now 
if on the other hand by look for something which is not there like and then find,if on the other hand i look for something which is not there like cat then find will 
an it gives me a value error saying the substring does not occur right so this is how find that,1 it gives me a value error saying the substring does not occur right this is how find and 
string now this can be controlled in the following way supposing i do not each a,string now this can be controlled in the following ways supposing i do not want to 
the beginning should be replaced so it says replace at most the first n copies and notice that,beginning should be replaced it says replace at most the first n copies and notice that 
or something else is not at s is going to change because strings are immutable is what,something else is not that s is going to change because strings are immutable is going 
this point the aim b is second if we have been so it will not find,this point the second aba has been destroyed so it will not find it 
it as if i had for instance two copies of this disjoint then it would have correctly,whereas if i had for instance two copies of this disjoint then it would have correctly 
like this it to the first column would be written followed by comma and second column so if we are,like this the first column would be written followed by comma then second column so if 
in hello then when we write it out as text you get six seven and hello,string hello then we write it out a text as you will get 6 7 and hello actually 
you something simpler so less just say that we had three numbers j six seven and eight for example,use something simpler so let us just say that we had three numbers 6 7 and 8 for example 
now what you want to do is we want to extract is information right so we want to extract,now what we want to do is we want to extract this information so we want to extract the 
first comma as first thing so columns is just the name that we are used to,first comma is a first thing so columns is just a name that we have used it could be 
of control how many splits you make so you can say split according to the string so no to,control how many splits you make so you can say split according to this string notice 
it is a kind of sequence like strings and list in a tuple you can extract one element,it is a kind of sequence so like strings and list in a tuple you can extract one element 
other thing to keep in mind is that though it is tempting to building that d dot keys,the other thing to keep in mind is that though it is tempting to believe that d dot keys 
start with an empty and now let us create for each letter an entry which is,us start with an empty dictionary and now let us create for each letter and entry which 
the same as the a to consist for n in the keys in the or i d,is the same as that letter so we can say for l in a b c d e f g h i d i d 
random east first in range the way down and so on is more specific or,random order so e is first and a is way down and so on there is no specific order 
sil another way to run through the values in the dictionary is to use d dot values,in other way to run through the values in a dictionary is to use d dot values so d 
s in test one dot values and added sil,s in test 1 dot values and add it to the total 
triples with falls otherwise the same is true of keys and so if i want to add up,it tells you false otherwise the same is true of keys so if i want to add up the 
even d values for because if it does not appear its illegal to says that,then you add a score because if it does not appear it is illegal to access that match 
association of values to keys then it a list the constraint that python,association of values to keys than you have in a list the only constraint that python 
is that we can use d dot keys to cycle through all the keys in a dictionary,the other thing is that we can use d dot keys to cycle through all the keys in the dictionary 
in similarly into of values but the order in which keys them and we emerge from d dot keys,and similarly d dot values but the order in which these keys emerge from d dot keys 
this kind of a sequence of values with around to write it is called it tuple,so this kind of a sequence of values with the round bracket is called a tuple 
keys to values,keys to values 
and what is the value associated so the and score is eighty four which are us to is sixty two,name what is the value associated so dhawanã£â€¢s score is 84 pujaraã£â€¢s score is 16 kohliã£â€¢s 
is what python pause the dictionary in some other programming languages this is also,this is what python calls a dictionary in some other programming languages this is also 
is that like a list it is mutable we can take a value with that key and replace it so we can j,is that like a list it is mutable we can take a value with a key and replace it so 
is to the error score if you want by an assignment to seventy two and this will just,we can change pujaraã£â€¢s score if you want by an assignment to 72 and this will just 
dictionaries can be updated in place in some mutable exactly like lists,so dictionaries can be updated in place and hence are mutable exactly like lists 
assign it to tuple of values for instance we can take a two dimensional point to take,and assign it a tuple of values for instance we can take a twodimensional point with x 
is to a all the players that we had for like dhawan and which are or so notice that,to all the players that we had before like dhawan and pujara and so on so notice that 
are associated with the name so that we can operate on it to the appropriate operations,associating with the name so that we can operate on it with the appropriate operations 
in each any immutable value that means we keep that the integer to the of four to be,be any immutable value that means your key could be an integer it could be a float 
in test one and the score in test and we can have more than one play and test two,in test 1 and the score in test 2 and we can have more than one player in test 2 like 
curly that it notation for each entry it will fill the key for whether the value,this kind of curly bracket notation where each entry will be the key followed by the 
so supposing we say score estimate one two seven six then this is going to give,keys so suppose we will say score test 1 dhawan equal to 76 now this is going to give 
similarly we can say that it d it is later of three parts that d and none and earlier an,similarly we can say that a date is made up of three parts a day a month and a year 
person it because we have into will be that score test one,us an error because we have not told it that score test 1 is suppose to be a dictionary 
will use it so is four plus two and now we can go back and set this,will use it so is score test 2 now we can go back and set dhawan's score 
set to least two in the first test to it in our the asking to show is what scores looks,set kohliã£â€¢s score in the first test to 200 now if you ask me to show what scores looks 
we can encloses this into a three value the triple tuple behaves like a list,and we can encloses into a three value or triple so tuple behaves like a list so 
so if we want to process a dictionary then we would be to run through all the values,if you want to process a dictionary then we would need to run through all the values 
and that the to the thing we will do is for every key in d dot keys do something,d and the typical thing we would do is for every key in d dot keys do something with 
do something with the value associated to five now one thing we have to keep in mind,do something with a value associated to that now one thing we have to keep in mind which 
just keep shifting temp,so just keep shifting temp 
the value b and we make this last node point to this new node,a value v and we make this last node point to this new node 
a completely different object,creates a completely different object 
said that if we pass a mutable value to a function so long as we do not reassign the,we said that if we pass a mutable value to a function so long as we do not reassign that 
into the function to the list of dictionary inside a function we get a new copy and then after that any change we,we reassign to the list or dictionary inside the function we get a new copy and then after 
we do is we do not change the identity of a node which change what it that takes,what we do is we do not change the identity of the node we change what it contains 
it,and not first 
here is the code for insert so as,here is the code for insert 
the guess or to change none to be insert an append to get the same way to,we just have to change none to v so insert and append both behave the same way with an 
the empty list,empty list 
go from the empty list two list v does not matter there inserting append,we go from the empty list to the list v it does not matter whether you are inserting 
otherwise,or appending 
we create this new node and then we do this swapping of values between,otherwise we create this new node and then we do this swapping of values between the 
value using this python simultaneous assignment,node dot value to self dot value using this python simultaneous assignment 
similarly we take self dot next which is pointing to the next node and make,and similarly we take self dot next which was pointing to the next node and make it 
in assigns all the delete requires us to do is to reassign the pointer from before,so in essense all that delete requires us to do is to reassign the pointer from before 
we scan the list for the first the now notice that in this from in procedure we need,we scan the list for the first v now notice that in this plumbing procedure we need to 
list can have value none,in a list can have value none right 
it then it will break the connection between the parameter pass in the thing we get back,object and it will break the connection between the parameter we passed and the thing we get 
same trick and what,we use the same trick 
so we just copy the value from that are and then we delete,so we just copy this value from here to here and then we delete v 2 
so we wanted to delete the first node we are not allowed to delete the first node with the,so we wanted to delete the first node we are not allowed to delete the first node because 
cannot change got l points to,we cannot change what l points to 
is a part of the delete function,here is a part of the delete function 
and so if it is empty we do nothing otherwise if this self dot value is x the first node,if it is empty we do nothing otherwise if this self dot value is x the first node is 
be none we are done,to be none and we are done 
all which is the case when the value to be deleted is in first node and the second,which is the case when the value to be deleted is in the first node and this is the second 
value to the first in by proceed as we did before otherwise,to the first and bypassing it as we did before 
us we just point of the next node and ask the next node the list starting at the,otherwise we just point to the next node and ask the next node the list starting at the 
next node what is normally called the tail of the list to delete v from itself right so,next node what is normally called the tail of the list to delete v from itself 
so we come here and then we delete it,so we come here and then we delete it 
none,none none 
so this is the first part is one we delete the first element in the list the recursive part,so the first part is when we delete the first element from a list but the recursive part 
none,none 
so we made this node the last node,so you make this node the last node 
so the or only thing that remember got recursive delete is when we reach the end of the list,the only thing to remember about recursive delete is when we reach the end of the list 
remove this node for,and remove this node 
so we first initialize our list that we are going to produce so the empty list if,so we first initialize our list that we are going to produce for the empty list 
so here we have code which exactly reflects what we did in the slides,here we have code which exactly reflects what we did in the slides 
so we start with is initial initialization weeks sets up the initial value to be none there,so we start with this initial initialization which sets the initial value to be none by 
common the slight by saying just return self dot value equal to equal to none but we have,form in the slide by saying just return self dot value equal to equal to none but we have 
creates a new node it if that we have reach the last node it creates a new node and,creates a new node if we have reached the last node it creates a new node and makes 
so the next insert function a again if it is empty then we just creates a singleton list otherwise,this insert function again if it is empty then it just creates a singleton list otherwise 
so that the what self points to this unchanged but rather we create a reordering and,that what self points to does not change but rather we create a reordering of the new 
sil recursive deletes again it says that it sil that or the for a if the list is empty then we do nothing,so the recursive delete again says that if the list is empty then we do nothing otherwise 
otherwise the first value to be deleted then we have to be careful and make sure we,if the first value is to be deleted then we have to be careful and we have to make sure 
and eventually returns the string representation of that is,and eventually returns a string representation of that list 
sil tree now run this by input in a then we could say for instance that or l is a list of the,if we now run this by importing then we could say for instance that l is a list with value 
this none do and say a for i in range one to one level sil l to get to it,this in a loop and say for i in range 1 say 11 l dot append i 
here is the basic class there two and reuse the class node so,here is the basic class that we are going to use it is a class node 
the initial value is by default none unless f provide evaluation value which tree,the initial value is by default none unless i provide you an initial value in which case 
in order to go through the list we have to start at the beginning and walk following,so in order to go through the list we have to start at the beginning and walk following 
we just point take the list we are pointing to look at the very first value which of these,we just take the list we are pointing to and look at the very first value which will be 
i ask whether l one is empty the answer will be true,if i ask whether l1 is empty the answer will be true 
so now we create a new element here with the value v and we make this element point,now we create a new element here with the value v and we make this element point to 
we create a new element the node b and set the next field of the last no,this we create a new element with the node v and set the next field of the last node 
so if it is empty then we just set the value so this is converts the single node,if it is empty then we just set the value to v so this just converts the single node 
it in a four nodes,there are 4 nodes 
so we have a number tree careful in this making sure that this is for,we have been abundantly careful in making sure that this is parsable 
are symbols so we have put this bracket saying that we take the object self dot next and apply append,so we have put this bracket saying that we take the object self dot next and apply append 
we need not actually put the bracket so we can just write self dot next dot append v and,we need not actually put the bracket we can just write self dot next dot append v and 
it so this dot is it in from the right in,so this dot is taken from the right 
come to the last lecture of this course so instead of going into more features,we have come to the last lecture of this course so instead of going into more features of 
keep writing statements without worry about what x is and what while is as you go along,and keep writing statements without worrying about what x is and what y is as you go along 
the code c waits inside the class code then as the maintainers of the class be would may,see if it is inside the class code then as the maintainers of the class we would make 
all the code within the last to be terms of r theta not of the but it somebody outside,the code within the class to be in terms of r theta and not x y but if somebody outside 
it person that code stops working because we have changed the internal implementation of,person their code stops working because we have changed an internal implementation of 
you can define values and manipulate the so that makes it very convenient and the,you can define values and manipulate them so that makes it very convenient and very 
the way we can get around this is to actually have some way of saying that these names are,way we can get around this is to actually have some way of saying that these names are 
set a function and say to first to the same immutable value outside so there are situations,inside a function and say it refers to the same immutable value outside there are situations 
declarations and make things more usable but it does not and this is one example,declarations and make things more usable but it does not and this is one example 
in languages like java or you will find a lot of declarations saying private and public,in languages like java or you will find a lot of declarations saying private and public 
implementation from the interface so actually in an idea word the implementation a,implementation from the interface actually in an ideal world the implementation must 
we can set of how we set it is through this function so if inside the functions we start self this,we can set now how we set it is through this function so if inside the functions we start 
of the new x and recompute the theta right so in this way if we have only these functions,for the new x and recompute the theta in this way if we have only these functions 
is a template it through these functions and we do not know the actual representation,are manipulated through these functions and we do not know the actual representation 
this is cumbersome for every part of the function of the data type we have to use these functions and parts,this is cumbersome for every part of the data type we have to use these functions and partly 
and tables private and only allow this treated axis so that they use in the appropriate,and variables private and only allow restricted access so that they are used in the appropriate 
the end another reason to have this style of access,anymore another reason to have this style of accessing 
values the sometimes you do not want it the which are values to the actually accessible,values is sometimes you do not want individual values to be actually accessed individually 
equal so if we update a or one we have to be careful that we are updating it,year so if we update day or month we have to be careful that we are updating it legally 
in the values which have to be preserved and you can preserve of those by controlling max,the values which have to be preserved and you can preserve those by controlling access 
so the so we can z you can said that a separately and come up separately,to them so you can say you cannot set the day separately and the month separately you 
not declare decide in advance that it reads the space for x for one integer us to more or,cannot decide in advance that it needs a space for x for one integer because tomorrow this 
space always an n dynamic manner as to keep as you a use a name it has to find space,space always in a dynamic manner it has to keep as you use a name it has to find space 
we mentioned that and earlier lecture the arrays and this,we mentioned that in an earlier lecture the difference between arrays and lists 
object base implementation to get to the i the left and we have to start with i and go to the,based implementation to get to the ith element we have to start with the head and go to the 
of this kind of user defined data types and the static part takes k or of all the standard,for this kind of user defined data types and the static part takes care of all the standard 
is or much more efficient then this,are much more efficient than lists 
space takes careful right similarly when we had a list if you remember when we want,space who takes care of it similarly when we had a list if you remember when we wanted 
and actually delete we just bypassed between said that the first element points,did not actually delete it we just bypassed it we said that the first element points 
it now we can no longer reach that value north and we use it because it is being declared,it now we can no longer reach that value nor can we reuse it because it has been declared 
is a so you start with the names that you have and you go and you mark this,here so you start with the names that you have and you go on you mark this thing 
now this could be a list l could be a list so it could be that this in turn points to,now this could be a list l could be a list it could be that this in turn points to the 
it memory so remember that all the things that you declare in advance are allocated static,memory so remember that all the things that you declare in advance are allocated statically 
if you have to find undo them you can say n score that one it on,you cannot undo them you cannot say hence forth i do not need them 
be that as a program runs longer and one the it will start taking up more and more memory,be that as the program runs longer and longer it will start taking up more and more memory 
will suffer of up time as this base shrinks so virtually speaking all order languages,will suffer over time as the space shrinks so virtually speaking all modern languages 
is use garbage collection because so much simpler though there is a run time overhead,use garbage collection because it is so much simpler though there is a runtime overhead 
i making sure that you are garbage collection works other new line on the put sense of,making sure that your garbage collection works rather than relying on the good sense of the 
you actually give a step by step prose is to compute things right so you assign a,language you actually give a step by step process to compute things you assign names 
is to keep track of intermediate values you put things and lists and then you have to basically,to keep track of intermediate values you put things in lists and then you have to basically 
a factorial of the function and this is itã•s type it takes a name integer as input then produces,factorial is a function and this is itã£â€¢s type it takes an integer as input and produces 
a way that haskell works is by rewriting we will not get into that but the main point,the actual way that haskell works is by rewriting we will not get into that but the main point 
is that there is no a no mention here about the intermediate names the is just taking the,is that there is no mention here about the intermediate names it is just taking the 
just write out a if you take the first element of the last element so if of a nonempty list,such as head or tail to take the first element or the last element so if you have a non 
of programming which is called declared programming and a you can look it up,of programming which is called declarative programming and you can look it up it is 
than will not know that use it goes to use x a not y because every new name that come,will not know that you were supposed to use x and not y because every new name that comes 
is kind of type was can be very heart to find and because you have this kind of,these kind of typos can be very very hard to find and because you have this kind of 
init well buffer many things you can just get by on the fly by this translate,learn it well but for many things you can just get by on the fly by just translating 
which so the it is an status of to learn a programming language nobody learns a programming,it is a mistake to sit and learn a programming language nobody learns a programming language 
before and therefore something is one so a miss type name l easily caught,before and therefore something is wrong so a miss typed name can be easily caught as 
assigning at some different type of value now if you are to announced to python that type,assigning it some different type of value now if you had announced to python that x 
the compiler it to catch it in ten so a lot of errors are either type pause and we able,a compiler it would catch it internally a lot of errors are either typos in variable 
very easily by compilers if you have declarations of names both the base that an caught,very easily by compilers if you have declarations of names both of these get uncaught or they 
can name has a type in particular we saw that we want to use something as a list we are,a name has a type in particular we saw that if we want to use something as a list we have 
user defined types if you have for instance it is very convenient to be able to define,user defined types that we have for instance it is very convenient to be able to define 
you can say that the name d is of type tree and then you can use this value like none,you can say that the name t is of type tree and then you can use this value like none 
none and you can use none for anything but when it a none it has no type,none and you can use none for anything but when it has none it has no type  that is 
as the difference so if python the name has the value none it has by definition node type where,the difference if in python a name has the value none it has by definition no type 
back of declaration makes things a little bit more complicated in python which one does a now,lack of declaration makes things a little bit more complicated in python which one doesnã£â€¢t 
many come across in beginning program the other thing is much most c is,normally come across in beginning programming the other thing is much more serious so 
this is more to do convenience and representation of empty of x but without declarations,this is more to do with convenience and representation of empty objects but without declarations 
push say we have queue maybe also a list but when we want the add and remove queue,push same way a queue may be also a list but we only want the add and remove queue 
in x and y and started manipulating p dot x and p dot y directly outside,using x and y and started manipulating p dot x and p dot y directly outside the code 
